// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "types.pb.h"
#include "object.pb.h"
#include "log.pb.h"
#include "motcmds.pb.h"
#include "test.pb.h"
#include "task.pb.h"
#include "canon.pb.h"
#include "rtapicommand.pb.h"
#include "rtapi_message.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Container;

// ===================================================================

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  void Swap(Container* other);

  // implements Message ----------------------------------------------

  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ContainerType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::ContainerType type() const;
  inline void set_type(::pb::ContainerType value);

  // optional .pb.MotionCommand motcmd = 9;
  inline bool has_motcmd() const;
  inline void clear_motcmd();
  static const int kMotcmdFieldNumber = 9;
  inline const ::pb::MotionCommand& motcmd() const;
  inline ::pb::MotionCommand* mutable_motcmd();
  inline ::pb::MotionCommand* release_motcmd();
  inline void set_allocated_motcmd(::pb::MotionCommand* motcmd);

  // optional .pb.MotionStatus motstat = 10;
  inline bool has_motstat() const;
  inline void clear_motstat();
  static const int kMotstatFieldNumber = 10;
  inline const ::pb::MotionStatus& motstat() const;
  inline ::pb::MotionStatus* mutable_motstat();
  inline ::pb::MotionStatus* release_motstat();
  inline void set_allocated_motstat(::pb::MotionStatus* motstat);

  // optional bytes legacy_motcmd = 11;
  inline bool has_legacy_motcmd() const;
  inline void clear_legacy_motcmd();
  static const int kLegacyMotcmdFieldNumber = 11;
  inline const ::std::string& legacy_motcmd() const;
  inline void set_legacy_motcmd(const ::std::string& value);
  inline void set_legacy_motcmd(const char* value);
  inline void set_legacy_motcmd(const void* value, size_t size);
  inline ::std::string* mutable_legacy_motcmd();
  inline ::std::string* release_legacy_motcmd();
  inline void set_allocated_legacy_motcmd(::std::string* legacy_motcmd);

  // optional bytes legacy_motstat = 12;
  inline bool has_legacy_motstat() const;
  inline void clear_legacy_motstat();
  static const int kLegacyMotstatFieldNumber = 12;
  inline const ::std::string& legacy_motstat() const;
  inline void set_legacy_motstat(const ::std::string& value);
  inline void set_legacy_motstat(const char* value);
  inline void set_legacy_motstat(const void* value, size_t size);
  inline ::std::string* mutable_legacy_motstat();
  inline ::std::string* release_legacy_motstat();
  inline void set_allocated_legacy_motstat(::std::string* legacy_motstat);

  // optional .pb.RTAPI_Message rtapi_message = 13;
  inline bool has_rtapi_message() const;
  inline void clear_rtapi_message();
  static const int kRtapiMessageFieldNumber = 13;
  inline const ::pb::RTAPI_Message& rtapi_message() const;
  inline ::pb::RTAPI_Message* mutable_rtapi_message();
  inline ::pb::RTAPI_Message* release_rtapi_message();
  inline void set_allocated_rtapi_message(::pb::RTAPI_Message* rtapi_message);

  // optional .pb.TaskReply task_reply = 14;
  inline bool has_task_reply() const;
  inline void clear_task_reply();
  static const int kTaskReplyFieldNumber = 14;
  inline const ::pb::TaskReply& task_reply() const;
  inline ::pb::TaskReply* mutable_task_reply();
  inline ::pb::TaskReply* release_task_reply();
  inline void set_allocated_task_reply(::pb::TaskReply* task_reply);

  // optional .pb.TicketUpdate ticket_update = 15;
  inline bool has_ticket_update() const;
  inline void clear_ticket_update();
  static const int kTicketUpdateFieldNumber = 15;
  inline const ::pb::TicketUpdate& ticket_update() const;
  inline ::pb::TicketUpdate* mutable_ticket_update();
  inline ::pb::TicketUpdate* release_ticket_update();
  inline void set_allocated_ticket_update(::pb::TicketUpdate* ticket_update);

  // optional bytes syslog = 18;
  inline bool has_syslog() const;
  inline void clear_syslog();
  static const int kSyslogFieldNumber = 18;
  inline const ::std::string& syslog() const;
  inline void set_syslog(const ::std::string& value);
  inline void set_syslog(const char* value);
  inline void set_syslog(const void* value, size_t size);
  inline ::std::string* mutable_syslog();
  inline ::std::string* release_syslog();
  inline void set_allocated_syslog(::std::string* syslog);

  // optional bytes legacy_nml = 19;
  inline bool has_legacy_nml() const;
  inline void clear_legacy_nml();
  static const int kLegacyNmlFieldNumber = 19;
  inline const ::std::string& legacy_nml() const;
  inline void set_legacy_nml(const ::std::string& value);
  inline void set_legacy_nml(const char* value);
  inline void set_legacy_nml(const void* value, size_t size);
  inline ::std::string* mutable_legacy_nml();
  inline ::std::string* release_legacy_nml();
  inline void set_allocated_legacy_nml(::std::string* legacy_nml);

  // optional bytes legacy_motconfig = 20;
  inline bool has_legacy_motconfig() const;
  inline void clear_legacy_motconfig();
  static const int kLegacyMotconfigFieldNumber = 20;
  inline const ::std::string& legacy_motconfig() const;
  inline void set_legacy_motconfig(const ::std::string& value);
  inline void set_legacy_motconfig(const char* value);
  inline void set_legacy_motconfig(const void* value, size_t size);
  inline ::std::string* mutable_legacy_motconfig();
  inline ::std::string* release_legacy_motconfig();
  inline void set_allocated_legacy_motconfig(::std::string* legacy_motconfig);

  // optional int32 tv_sec = 21;
  inline bool has_tv_sec() const;
  inline void clear_tv_sec();
  static const int kTvSecFieldNumber = 21;
  inline ::google::protobuf::int32 tv_sec() const;
  inline void set_tv_sec(::google::protobuf::int32 value);

  // optional int32 tv_nsec = 22;
  inline bool has_tv_nsec() const;
  inline void clear_tv_nsec();
  static const int kTvNsecFieldNumber = 22;
  inline ::google::protobuf::int32 tv_nsec() const;
  inline void set_tv_nsec(::google::protobuf::int32 value);

  // optional string topic = 23;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 23;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional bool reply_required = 24;
  inline bool has_reply_required() const;
  inline void clear_reply_required();
  static const int kReplyRequiredFieldNumber = 24;
  inline bool reply_required() const;
  inline void set_reply_required(bool value);

  // optional int32 rsvp = 30;
  inline bool has_rsvp() const;
  inline void clear_rsvp();
  static const int kRsvpFieldNumber = 30;
  inline ::google::protobuf::int32 rsvp() const;
  inline void set_rsvp(::google::protobuf::int32 value);

  // optional .pb.ContainerType in_reply_to = 33;
  inline bool has_in_reply_to() const;
  inline void clear_in_reply_to();
  static const int kInReplyToFieldNumber = 33;
  inline ::pb::ContainerType in_reply_to() const;
  inline void set_in_reply_to(::pb::ContainerType value);

  // optional .pb.RCS_STATUS rcs_status = 35;
  inline bool has_rcs_status() const;
  inline void clear_rcs_status();
  static const int kRcsStatusFieldNumber = 35;
  inline ::pb::RCS_STATUS rcs_status() const;
  inline void set_rcs_status(::pb::RCS_STATUS value);

  // optional .pb.StatusType status = 40;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 40;
  inline ::pb::StatusType status() const;
  inline void set_status(::pb::StatusType value);

  // optional int32 serial = 45;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 45;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // optional int32 reply_serial = 50;
  inline bool has_reply_serial() const;
  inline void clear_reply_serial();
  static const int kReplySerialFieldNumber = 50;
  inline ::google::protobuf::int32 reply_serial() const;
  inline void set_reply_serial(::google::protobuf::int32 value);

  // optional int32 ticket = 55;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 55;
  inline ::google::protobuf::int32 ticket() const;
  inline void set_ticket(::google::protobuf::int32 value);

  // optional int32 reply_ticket = 60;
  inline bool has_reply_ticket() const;
  inline void clear_reply_ticket();
  static const int kReplyTicketFieldNumber = 60;
  inline ::google::protobuf::int32 reply_ticket() const;
  inline void set_reply_ticket(::google::protobuf::int32 value);

  // optional int32 sequence = 62;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 62;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);

  // optional int32 credit = 65;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 65;
  inline ::google::protobuf::int32 credit() const;
  inline void set_credit(::google::protobuf::int32 value);

  // optional int32 line_number = 66;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 66;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);

  // optional string name = 67;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 67;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string note = 68;
  inline int note_size() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 68;
  inline const ::std::string& note(int index) const;
  inline ::std::string* mutable_note(int index);
  inline void set_note(int index, const ::std::string& value);
  inline void set_note(int index, const char* value);
  inline void set_note(int index, const char* value, size_t size);
  inline ::std::string* add_note();
  inline void add_note(const ::std::string& value);
  inline void add_note(const char* value);
  inline void add_note(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& note() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_note();

  // optional int32 retcode = 69;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 69;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // optional .pb.AnError error = 70;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 70;
  inline const ::pb::AnError& error() const;
  inline ::pb::AnError* mutable_error();
  inline ::pb::AnError* release_error();
  inline void set_allocated_error(::pb::AnError* error);

  // optional bytes uuid = 72;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 72;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bool trace = 75;
  inline bool has_trace() const;
  inline void clear_trace();
  static const int kTraceFieldNumber = 75;
  inline bool trace() const;
  inline void set_trace(bool value);

  // optional int32 instance = 77;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 77;
  inline ::google::protobuf::int32 instance() const;
  inline void set_instance(::google::protobuf::int32 value);

  // optional .pb.Originator origin = 80;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 80;
  inline const ::pb::Originator& origin() const;
  inline ::pb::Originator* mutable_origin();
  inline ::pb::Originator* release_origin();
  inline void set_allocated_origin(::pb::Originator* origin);

  // optional .pb.RTAPICommand rtapicmd = 86;
  inline bool has_rtapicmd() const;
  inline void clear_rtapicmd();
  static const int kRtapicmdFieldNumber = 86;
  inline const ::pb::RTAPICommand& rtapicmd() const;
  inline ::pb::RTAPICommand* mutable_rtapicmd();
  inline ::pb::RTAPICommand* release_rtapicmd();
  inline void set_allocated_rtapicmd(::pb::RTAPICommand* rtapicmd);

  // repeated .pb.ServiceAnnouncement service_announcement = 88;
  inline int service_announcement_size() const;
  inline void clear_service_announcement();
  static const int kServiceAnnouncementFieldNumber = 88;
  inline const ::pb::ServiceAnnouncement& service_announcement(int index) const;
  inline ::pb::ServiceAnnouncement* mutable_service_announcement(int index);
  inline ::pb::ServiceAnnouncement* add_service_announcement();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >&
      service_announcement() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >*
      mutable_service_announcement();

  // repeated .pb.Component comp = 100;
  inline int comp_size() const;
  inline void clear_comp();
  static const int kCompFieldNumber = 100;
  inline const ::pb::Component& comp(int index) const;
  inline ::pb::Component* mutable_comp(int index);
  inline ::pb::Component* add_comp();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Component >&
      comp() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Component >*
      mutable_comp();

  // repeated .pb.Pin pin = 2;
  inline int pin_size() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 2;
  inline const ::pb::Pin& pin(int index) const;
  inline ::pb::Pin* mutable_pin(int index);
  inline ::pb::Pin* add_pin();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Pin >&
      pin() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Pin >*
      mutable_pin();

  // repeated .pb.Signal signal = 3;
  inline int signal_size() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 3;
  inline const ::pb::Signal& signal(int index) const;
  inline ::pb::Signal* mutable_signal(int index);
  inline ::pb::Signal* add_signal();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Signal >&
      signal() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Signal >*
      mutable_signal();

  // repeated .pb.Param param = 103;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 103;
  inline const ::pb::Param& param(int index) const;
  inline ::pb::Param* mutable_param(int index);
  inline ::pb::Param* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Param >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Param >*
      mutable_param();

  // repeated .pb.Thread thread = 104;
  inline int thread_size() const;
  inline void clear_thread();
  static const int kThreadFieldNumber = 104;
  inline const ::pb::Thread& thread(int index) const;
  inline ::pb::Thread* mutable_thread(int index);
  inline ::pb::Thread* add_thread();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Thread >&
      thread() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Thread >*
      mutable_thread();

  // repeated .pb.Ring ring = 105;
  inline int ring_size() const;
  inline void clear_ring();
  static const int kRingFieldNumber = 105;
  inline const ::pb::Ring& ring(int index) const;
  inline ::pb::Ring* mutable_ring(int index);
  inline ::pb::Ring* add_ring();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Ring >&
      ring() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Ring >*
      mutable_ring();

  // repeated .pb.Group group = 106;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 106;
  inline const ::pb::Group& group(int index) const;
  inline ::pb::Group* mutable_group(int index);
  inline ::pb::Group* add_group();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Group >&
      group() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Group >*
      mutable_group();

  // repeated .pb.Member member = 107;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 107;
  inline const ::pb::Member& member(int index) const;
  inline ::pb::Member* mutable_member(int index);
  inline ::pb::Member* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Member >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Member >*
      mutable_member();

  // repeated .pb.Function function = 108;
  inline int function_size() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 108;
  inline const ::pb::Function& function(int index) const;
  inline ::pb::Function* mutable_function(int index);
  inline ::pb::Function* add_function();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Function >&
      function() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Function >*
      mutable_function();

  // optional string ascii = 140;
  inline bool has_ascii() const;
  inline void clear_ascii();
  static const int kAsciiFieldNumber = 140;
  inline const ::std::string& ascii() const;
  inline void set_ascii(const ::std::string& value);
  inline void set_ascii(const char* value);
  inline void set_ascii(const char* value, size_t size);
  inline ::std::string* mutable_ascii();
  inline ::std::string* release_ascii();
  inline void set_allocated_ascii(::std::string* ascii);

  // optional bytes unicode = 141;
  inline bool has_unicode() const;
  inline void clear_unicode();
  static const int kUnicodeFieldNumber = 141;
  inline const ::std::string& unicode() const;
  inline void set_unicode(const ::std::string& value);
  inline void set_unicode(const char* value);
  inline void set_unicode(const void* value, size_t size);
  inline ::std::string* mutable_unicode();
  inline ::std::string* release_unicode();
  inline void set_allocated_unicode(::std::string* unicode);

  // optional string gcode = 142;
  inline bool has_gcode() const;
  inline void clear_gcode();
  static const int kGcodeFieldNumber = 142;
  inline const ::std::string& gcode() const;
  inline void set_gcode(const ::std::string& value);
  inline void set_gcode(const char* value);
  inline void set_gcode(const char* value, size_t size);
  inline ::std::string* mutable_gcode();
  inline ::std::string* release_gcode();
  inline void set_allocated_gcode(::std::string* gcode);

  // optional string python = 143;
  inline bool has_python() const;
  inline void clear_python();
  static const int kPythonFieldNumber = 143;
  inline const ::std::string& python() const;
  inline void set_python(const ::std::string& value);
  inline void set_python(const char* value);
  inline void set_python(const char* value, size_t size);
  inline ::std::string* mutable_python();
  inline ::std::string* release_python();
  inline void set_allocated_python(::std::string* python);

  // optional bytes pickle = 144;
  inline bool has_pickle() const;
  inline void clear_pickle();
  static const int kPickleFieldNumber = 144;
  inline const ::std::string& pickle() const;
  inline void set_pickle(const ::std::string& value);
  inline void set_pickle(const char* value);
  inline void set_pickle(const void* value, size_t size);
  inline ::std::string* mutable_pickle();
  inline ::std::string* release_pickle();
  inline void set_allocated_pickle(::std::string* pickle);

  // optional string tcl = 145;
  inline bool has_tcl() const;
  inline void clear_tcl();
  static const int kTclFieldNumber = 145;
  inline const ::std::string& tcl() const;
  inline void set_tcl(const ::std::string& value);
  inline void set_tcl(const char* value);
  inline void set_tcl(const char* value, size_t size);
  inline ::std::string* mutable_tcl();
  inline ::std::string* release_tcl();
  inline void set_allocated_tcl(::std::string* tcl);

  // optional string xml = 146;
  inline bool has_xml() const;
  inline void clear_xml();
  static const int kXmlFieldNumber = 146;
  inline const ::std::string& xml() const;
  inline void set_xml(const ::std::string& value);
  inline void set_xml(const char* value);
  inline void set_xml(const char* value, size_t size);
  inline ::std::string* mutable_xml();
  inline ::std::string* release_xml();
  inline void set_allocated_xml(::std::string* xml);

  // optional string json = 147;
  inline bool has_json() const;
  inline void clear_json();
  static const int kJsonFieldNumber = 147;
  inline const ::std::string& json() const;
  inline void set_json(const ::std::string& value);
  inline void set_json(const char* value);
  inline void set_json(const char* value, size_t size);
  inline ::std::string* mutable_json();
  inline ::std::string* release_json();
  inline void set_allocated_json(::std::string* json);

  // optional bytes jpeg = 148;
  inline bool has_jpeg() const;
  inline void clear_jpeg();
  static const int kJpegFieldNumber = 148;
  inline const ::std::string& jpeg() const;
  inline void set_jpeg(const ::std::string& value);
  inline void set_jpeg(const char* value);
  inline void set_jpeg(const void* value, size_t size);
  inline ::std::string* mutable_jpeg();
  inline ::std::string* release_jpeg();
  inline void set_allocated_jpeg(::std::string* jpeg);

  // optional bytes png = 149;
  inline bool has_png() const;
  inline void clear_png();
  static const int kPngFieldNumber = 149;
  inline const ::std::string& png() const;
  inline void set_png(const ::std::string& value);
  inline void set_png(const char* value);
  inline void set_png(const void* value, size_t size);
  inline ::std::string* mutable_png();
  inline ::std::string* release_png();
  inline void set_allocated_png(::std::string* png);

  // optional bytes tiff = 150;
  inline bool has_tiff() const;
  inline void clear_tiff();
  static const int kTiffFieldNumber = 150;
  inline const ::std::string& tiff() const;
  inline void set_tiff(const ::std::string& value);
  inline void set_tiff(const char* value);
  inline void set_tiff(const void* value, size_t size);
  inline ::std::string* mutable_tiff();
  inline ::std::string* release_tiff();
  inline void set_allocated_tiff(::std::string* tiff);

  // optional bytes postscript = 151;
  inline bool has_postscript() const;
  inline void clear_postscript();
  static const int kPostscriptFieldNumber = 151;
  inline const ::std::string& postscript() const;
  inline void set_postscript(const ::std::string& value);
  inline void set_postscript(const char* value);
  inline void set_postscript(const void* value, size_t size);
  inline ::std::string* mutable_postscript();
  inline ::std::string* release_postscript();
  inline void set_allocated_postscript(::std::string* postscript);

  // optional bytes svg = 152;
  inline bool has_svg() const;
  inline void clear_svg();
  static const int kSvgFieldNumber = 152;
  inline const ::std::string& svg() const;
  inline void set_svg(const ::std::string& value);
  inline void set_svg(const char* value);
  inline void set_svg(const void* value, size_t size);
  inline ::std::string* mutable_svg();
  inline ::std::string* release_svg();
  inline void set_allocated_svg(::std::string* svg);

  // optional bytes wou = 160;
  inline bool has_wou() const;
  inline void clear_wou();
  static const int kWouFieldNumber = 160;
  inline const ::std::string& wou() const;
  inline void set_wou(const ::std::string& value);
  inline void set_wou(const char* value);
  inline void set_wou(const void* value, size_t size);
  inline ::std::string* mutable_wou();
  inline ::std::string* release_wou();
  inline void set_allocated_wou(::std::string* wou);

  // optional .pb.LogMessage log_message = 87;
  inline bool has_log_message() const;
  inline void clear_log_message();
  static const int kLogMessageFieldNumber = 87;
  inline const ::pb::LogMessage& log_message() const;
  inline ::pb::LogMessage* mutable_log_message();
  inline ::pb::LogMessage* release_log_message();
  inline void set_allocated_log_message(::pb::LogMessage* log_message);

  // optional .pb.TaskPlanExecute tpexecute = 200;
  inline bool has_tpexecute() const;
  inline void clear_tpexecute();
  static const int kTpexecuteFieldNumber = 200;
  inline const ::pb::TaskPlanExecute& tpexecute() const;
  inline ::pb::TaskPlanExecute* mutable_tpexecute();
  inline ::pb::TaskPlanExecute* release_tpexecute();
  inline void set_allocated_tpexecute(::pb::TaskPlanExecute* tpexecute);

  // optional .pb.TaskPlanBlockDelete tpblockdelete = 201;
  inline bool has_tpblockdelete() const;
  inline void clear_tpblockdelete();
  static const int kTpblockdeleteFieldNumber = 201;
  inline const ::pb::TaskPlanBlockDelete& tpblockdelete() const;
  inline ::pb::TaskPlanBlockDelete* mutable_tpblockdelete();
  inline ::pb::TaskPlanBlockDelete* release_tpblockdelete();
  inline void set_allocated_tpblockdelete(::pb::TaskPlanBlockDelete* tpblockdelete);

  // optional .pb.TaskPlanOptionalStop tpoptionalstop = 202;
  inline bool has_tpoptionalstop() const;
  inline void clear_tpoptionalstop();
  static const int kTpoptionalstopFieldNumber = 202;
  inline const ::pb::TaskPlanOptionalStop& tpoptionalstop() const;
  inline ::pb::TaskPlanOptionalStop* mutable_tpoptionalstop();
  inline ::pb::TaskPlanOptionalStop* release_tpoptionalstop();
  inline void set_allocated_tpoptionalstop(::pb::TaskPlanOptionalStop* tpoptionalstop);

  // optional .pb.TaskPlanOpen tpopen = 203;
  inline bool has_tpopen() const;
  inline void clear_tpopen();
  static const int kTpopenFieldNumber = 203;
  inline const ::pb::TaskPlanOpen& tpopen() const;
  inline ::pb::TaskPlanOpen* mutable_tpopen();
  inline ::pb::TaskPlanOpen* release_tpopen();
  inline void set_allocated_tpopen(::pb::TaskPlanOpen* tpopen);

  // optional .pb.TaskPlanReply taskplan_reply = 210;
  inline bool has_taskplan_reply() const;
  inline void clear_taskplan_reply();
  static const int kTaskplanReplyFieldNumber = 210;
  inline const ::pb::TaskPlanReply& taskplan_reply() const;
  inline ::pb::TaskPlanReply* mutable_taskplan_reply();
  inline ::pb::TaskPlanReply* release_taskplan_reply();
  inline void set_allocated_taskplan_reply(::pb::TaskPlanReply* taskplan_reply);

  // optional .pb.Emc_Traj_Set_G5x traj_set_g5x = 300;
  inline bool has_traj_set_g5x() const;
  inline void clear_traj_set_g5x();
  static const int kTrajSetG5XFieldNumber = 300;
  inline const ::pb::Emc_Traj_Set_G5x& traj_set_g5x() const;
  inline ::pb::Emc_Traj_Set_G5x* mutable_traj_set_g5x();
  inline ::pb::Emc_Traj_Set_G5x* release_traj_set_g5x();
  inline void set_allocated_traj_set_g5x(::pb::Emc_Traj_Set_G5x* traj_set_g5x);

  // optional .pb.Emc_Traj_Set_G92 traj_set_g92 = 310;
  inline bool has_traj_set_g92() const;
  inline void clear_traj_set_g92();
  static const int kTrajSetG92FieldNumber = 310;
  inline const ::pb::Emc_Traj_Set_G92& traj_set_g92() const;
  inline ::pb::Emc_Traj_Set_G92* mutable_traj_set_g92();
  inline ::pb::Emc_Traj_Set_G92* release_traj_set_g92();
  inline void set_allocated_traj_set_g92(::pb::Emc_Traj_Set_G92* traj_set_g92);

  // optional .pb.Emc_Traj_Set_Rotation traj_set_rotation = 320;
  inline bool has_traj_set_rotation() const;
  inline void clear_traj_set_rotation();
  static const int kTrajSetRotationFieldNumber = 320;
  inline const ::pb::Emc_Traj_Set_Rotation& traj_set_rotation() const;
  inline ::pb::Emc_Traj_Set_Rotation* mutable_traj_set_rotation();
  inline ::pb::Emc_Traj_Set_Rotation* release_traj_set_rotation();
  inline void set_allocated_traj_set_rotation(::pb::Emc_Traj_Set_Rotation* traj_set_rotation);

  // optional .pb.Emc_Traj_Linear_Move traj_linear_move = 330;
  inline bool has_traj_linear_move() const;
  inline void clear_traj_linear_move();
  static const int kTrajLinearMoveFieldNumber = 330;
  inline const ::pb::Emc_Traj_Linear_Move& traj_linear_move() const;
  inline ::pb::Emc_Traj_Linear_Move* mutable_traj_linear_move();
  inline ::pb::Emc_Traj_Linear_Move* release_traj_linear_move();
  inline void set_allocated_traj_linear_move(::pb::Emc_Traj_Linear_Move* traj_linear_move);

  // optional .pb.Emc_Traj_Probe traj_probe = 340;
  inline bool has_traj_probe() const;
  inline void clear_traj_probe();
  static const int kTrajProbeFieldNumber = 340;
  inline const ::pb::Emc_Traj_Probe& traj_probe() const;
  inline ::pb::Emc_Traj_Probe* mutable_traj_probe();
  inline ::pb::Emc_Traj_Probe* release_traj_probe();
  inline void set_allocated_traj_probe(::pb::Emc_Traj_Probe* traj_probe);

  // optional .pb.Emc_Traj_Circular_Move traj_circular_move = 350;
  inline bool has_traj_circular_move() const;
  inline void clear_traj_circular_move();
  static const int kTrajCircularMoveFieldNumber = 350;
  inline const ::pb::Emc_Traj_Circular_Move& traj_circular_move() const;
  inline ::pb::Emc_Traj_Circular_Move* mutable_traj_circular_move();
  inline ::pb::Emc_Traj_Circular_Move* release_traj_circular_move();
  inline void set_allocated_traj_circular_move(::pb::Emc_Traj_Circular_Move* traj_circular_move);

  // optional .pb.Emc_Traj_Rigid_Tap traj_rigid_tap = 360;
  inline bool has_traj_rigid_tap() const;
  inline void clear_traj_rigid_tap();
  static const int kTrajRigidTapFieldNumber = 360;
  inline const ::pb::Emc_Traj_Rigid_Tap& traj_rigid_tap() const;
  inline ::pb::Emc_Traj_Rigid_Tap* mutable_traj_rigid_tap();
  inline ::pb::Emc_Traj_Rigid_Tap* release_traj_rigid_tap();
  inline void set_allocated_traj_rigid_tap(::pb::Emc_Traj_Rigid_Tap* traj_rigid_tap);

  // optional .pb.Emc_Traj_Set_Term_Cond traj_set_term_cond = 370;
  inline bool has_traj_set_term_cond() const;
  inline void clear_traj_set_term_cond();
  static const int kTrajSetTermCondFieldNumber = 370;
  inline const ::pb::Emc_Traj_Set_Term_Cond& traj_set_term_cond() const;
  inline ::pb::Emc_Traj_Set_Term_Cond* mutable_traj_set_term_cond();
  inline ::pb::Emc_Traj_Set_Term_Cond* release_traj_set_term_cond();
  inline void set_allocated_traj_set_term_cond(::pb::Emc_Traj_Set_Term_Cond* traj_set_term_cond);

  // optional .pb.Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
  inline bool has_traj_set_spindlesync() const;
  inline void clear_traj_set_spindlesync();
  static const int kTrajSetSpindlesyncFieldNumber = 380;
  inline const ::pb::Emc_Traj_Set_Spindlesync& traj_set_spindlesync() const;
  inline ::pb::Emc_Traj_Set_Spindlesync* mutable_traj_set_spindlesync();
  inline ::pb::Emc_Traj_Set_Spindlesync* release_traj_set_spindlesync();
  inline void set_allocated_traj_set_spindlesync(::pb::Emc_Traj_Set_Spindlesync* traj_set_spindlesync);

  // optional .pb.Emc_Traj_Delay traj_delay = 390;
  inline bool has_traj_delay() const;
  inline void clear_traj_delay();
  static const int kTrajDelayFieldNumber = 390;
  inline const ::pb::Emc_Traj_Delay& traj_delay() const;
  inline ::pb::Emc_Traj_Delay* mutable_traj_delay();
  inline ::pb::Emc_Traj_Delay* release_traj_delay();
  inline void set_allocated_traj_delay(::pb::Emc_Traj_Delay* traj_delay);

  // optional .pb.Emc_Spindle_On spindle_on = 400;
  inline bool has_spindle_on() const;
  inline void clear_spindle_on();
  static const int kSpindleOnFieldNumber = 400;
  inline const ::pb::Emc_Spindle_On& spindle_on() const;
  inline ::pb::Emc_Spindle_On* mutable_spindle_on();
  inline ::pb::Emc_Spindle_On* release_spindle_on();
  inline void set_allocated_spindle_on(::pb::Emc_Spindle_On* spindle_on);

  // optional .pb.Emc_Spindle_Speed spindle_speed = 410;
  inline bool has_spindle_speed() const;
  inline void clear_spindle_speed();
  static const int kSpindleSpeedFieldNumber = 410;
  inline const ::pb::Emc_Spindle_Speed& spindle_speed() const;
  inline ::pb::Emc_Spindle_Speed* mutable_spindle_speed();
  inline ::pb::Emc_Spindle_Speed* release_spindle_speed();
  inline void set_allocated_spindle_speed(::pb::Emc_Spindle_Speed* spindle_speed);

  // optional .pb.Emc_Spindle_Orient spindle_orient = 420;
  inline bool has_spindle_orient() const;
  inline void clear_spindle_orient();
  static const int kSpindleOrientFieldNumber = 420;
  inline const ::pb::Emc_Spindle_Orient& spindle_orient() const;
  inline ::pb::Emc_Spindle_Orient* mutable_spindle_orient();
  inline ::pb::Emc_Spindle_Orient* release_spindle_orient();
  inline void set_allocated_spindle_orient(::pb::Emc_Spindle_Orient* spindle_orient);

  // optional .pb.Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
  inline bool has_spindle_wait_orient_complete() const;
  inline void clear_spindle_wait_orient_complete();
  static const int kSpindleWaitOrientCompleteFieldNumber = 430;
  inline const ::pb::Emc_Spindle_Wait_Orient_Complete& spindle_wait_orient_complete() const;
  inline ::pb::Emc_Spindle_Wait_Orient_Complete* mutable_spindle_wait_orient_complete();
  inline ::pb::Emc_Spindle_Wait_Orient_Complete* release_spindle_wait_orient_complete();
  inline void set_allocated_spindle_wait_orient_complete(::pb::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete);

  // optional .pb.Emc_Tool_Set_Offset tool_set_offet = 440;
  inline bool has_tool_set_offet() const;
  inline void clear_tool_set_offet();
  static const int kToolSetOffetFieldNumber = 440;
  inline const ::pb::Emc_Tool_Set_Offset& tool_set_offet() const;
  inline ::pb::Emc_Tool_Set_Offset* mutable_tool_set_offet();
  inline ::pb::Emc_Tool_Set_Offset* release_tool_set_offet();
  inline void set_allocated_tool_set_offet(::pb::Emc_Tool_Set_Offset* tool_set_offet);

  // optional .pb.Emc_Traj_Set_Offset traj_set_offset = 450;
  inline bool has_traj_set_offset() const;
  inline void clear_traj_set_offset();
  static const int kTrajSetOffsetFieldNumber = 450;
  inline const ::pb::Emc_Traj_Set_Offset& traj_set_offset() const;
  inline ::pb::Emc_Traj_Set_Offset* mutable_traj_set_offset();
  inline ::pb::Emc_Traj_Set_Offset* release_traj_set_offset();
  inline void set_allocated_traj_set_offset(::pb::Emc_Traj_Set_Offset* traj_set_offset);

  // optional .pb.Emc_Tool_Prepare tool_prepare = 460;
  inline bool has_tool_prepare() const;
  inline void clear_tool_prepare();
  static const int kToolPrepareFieldNumber = 460;
  inline const ::pb::Emc_Tool_Prepare& tool_prepare() const;
  inline ::pb::Emc_Tool_Prepare* mutable_tool_prepare();
  inline ::pb::Emc_Tool_Prepare* release_tool_prepare();
  inline void set_allocated_tool_prepare(::pb::Emc_Tool_Prepare* tool_prepare);

  // optional .pb.Emc_Tool_Set_Number tool_set_number = 470;
  inline bool has_tool_set_number() const;
  inline void clear_tool_set_number();
  static const int kToolSetNumberFieldNumber = 470;
  inline const ::pb::Emc_Tool_Set_Number& tool_set_number() const;
  inline ::pb::Emc_Tool_Set_Number* mutable_tool_set_number();
  inline ::pb::Emc_Tool_Set_Number* release_tool_set_number();
  inline void set_allocated_tool_set_number(::pb::Emc_Tool_Set_Number* tool_set_number);

  // optional .pb.Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
  inline bool has_traj_set_fo_enable() const;
  inline void clear_traj_set_fo_enable();
  static const int kTrajSetFoEnableFieldNumber = 480;
  inline const ::pb::Emc_Traj_Set_Fo_Enable& traj_set_fo_enable() const;
  inline ::pb::Emc_Traj_Set_Fo_Enable* mutable_traj_set_fo_enable();
  inline ::pb::Emc_Traj_Set_Fo_Enable* release_traj_set_fo_enable();
  inline void set_allocated_traj_set_fo_enable(::pb::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable);

  // optional .pb.Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
  inline bool has_traj_set_so_enable() const;
  inline void clear_traj_set_so_enable();
  static const int kTrajSetSoEnableFieldNumber = 490;
  inline const ::pb::Emc_Traj_Set_So_Enable& traj_set_so_enable() const;
  inline ::pb::Emc_Traj_Set_So_Enable* mutable_traj_set_so_enable();
  inline ::pb::Emc_Traj_Set_So_Enable* release_traj_set_so_enable();
  inline void set_allocated_traj_set_so_enable(::pb::Emc_Traj_Set_So_Enable* traj_set_so_enable);

  // optional .pb.Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
  inline bool has_traj_set_fh_enable() const;
  inline void clear_traj_set_fh_enable();
  static const int kTrajSetFhEnableFieldNumber = 500;
  inline const ::pb::Emc_Traj_Set_Fh_Enable& traj_set_fh_enable() const;
  inline ::pb::Emc_Traj_Set_Fh_Enable* mutable_traj_set_fh_enable();
  inline ::pb::Emc_Traj_Set_Fh_Enable* release_traj_set_fh_enable();
  inline void set_allocated_traj_set_fh_enable(::pb::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable);

  // optional .pb.Emc_Motion_Adaptive motion_adaptive = 510;
  inline bool has_motion_adaptive() const;
  inline void clear_motion_adaptive();
  static const int kMotionAdaptiveFieldNumber = 510;
  inline const ::pb::Emc_Motion_Adaptive& motion_adaptive() const;
  inline ::pb::Emc_Motion_Adaptive* mutable_motion_adaptive();
  inline ::pb::Emc_Motion_Adaptive* release_motion_adaptive();
  inline void set_allocated_motion_adaptive(::pb::Emc_Motion_Adaptive* motion_adaptive);

  // optional .pb.Emc_Operator_Display operator_display = 520;
  inline bool has_operator_display() const;
  inline void clear_operator_display();
  static const int kOperatorDisplayFieldNumber = 520;
  inline const ::pb::Emc_Operator_Display& operator_display() const;
  inline ::pb::Emc_Operator_Display* mutable_operator_display();
  inline ::pb::Emc_Operator_Display* release_operator_display();
  inline void set_allocated_operator_display(::pb::Emc_Operator_Display* operator_display);

  // optional .pb.Emc_Operator_Text operator_text = 530;
  inline bool has_operator_text() const;
  inline void clear_operator_text();
  static const int kOperatorTextFieldNumber = 530;
  inline const ::pb::Emc_Operator_Text& operator_text() const;
  inline ::pb::Emc_Operator_Text* mutable_operator_text();
  inline ::pb::Emc_Operator_Text* release_operator_text();
  inline void set_allocated_operator_text(::pb::Emc_Operator_Text* operator_text);

  // optional .pb.Emc_Operator_Error operator_error = 540;
  inline bool has_operator_error() const;
  inline void clear_operator_error();
  static const int kOperatorErrorFieldNumber = 540;
  inline const ::pb::Emc_Operator_Error& operator_error() const;
  inline ::pb::Emc_Operator_Error* mutable_operator_error();
  inline ::pb::Emc_Operator_Error* release_operator_error();
  inline void set_allocated_operator_error(::pb::Emc_Operator_Error* operator_error);

  // optional .pb.Emc_Motion_Set_Dout motion_set_dout = 550;
  inline bool has_motion_set_dout() const;
  inline void clear_motion_set_dout();
  static const int kMotionSetDoutFieldNumber = 550;
  inline const ::pb::Emc_Motion_Set_Dout& motion_set_dout() const;
  inline ::pb::Emc_Motion_Set_Dout* mutable_motion_set_dout();
  inline ::pb::Emc_Motion_Set_Dout* release_motion_set_dout();
  inline void set_allocated_motion_set_dout(::pb::Emc_Motion_Set_Dout* motion_set_dout);

  // optional .pb.Emc_Motion_Set_Aout motion_set_aout = 560;
  inline bool has_motion_set_aout() const;
  inline void clear_motion_set_aout();
  static const int kMotionSetAoutFieldNumber = 560;
  inline const ::pb::Emc_Motion_Set_Aout& motion_set_aout() const;
  inline ::pb::Emc_Motion_Set_Aout* mutable_motion_set_aout();
  inline ::pb::Emc_Motion_Set_Aout* release_motion_set_aout();
  inline void set_allocated_motion_set_aout(::pb::Emc_Motion_Set_Aout* motion_set_aout);

  // optional .pb.Emc_Aux_Input_Wait aux_input_wait = 570;
  inline bool has_aux_input_wait() const;
  inline void clear_aux_input_wait();
  static const int kAuxInputWaitFieldNumber = 570;
  inline const ::pb::Emc_Aux_Input_Wait& aux_input_wait() const;
  inline ::pb::Emc_Aux_Input_Wait* mutable_aux_input_wait();
  inline ::pb::Emc_Aux_Input_Wait* release_aux_input_wait();
  inline void set_allocated_aux_input_wait(::pb::Emc_Aux_Input_Wait* aux_input_wait);

  // optional .pb.Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
  inline bool has_exec_plugin_call() const;
  inline void clear_exec_plugin_call();
  static const int kExecPluginCallFieldNumber = 580;
  inline const ::pb::Emc_Exec_Plugin_Ca1l& exec_plugin_call() const;
  inline ::pb::Emc_Exec_Plugin_Ca1l* mutable_exec_plugin_call();
  inline ::pb::Emc_Exec_Plugin_Ca1l* release_exec_plugin_call();
  inline void set_allocated_exec_plugin_call(::pb::Emc_Exec_Plugin_Ca1l* exec_plugin_call);

  // optional .pb.Emc_Io_Plugin_Call io_plugin_call = 590;
  inline bool has_io_plugin_call() const;
  inline void clear_io_plugin_call();
  static const int kIoPluginCallFieldNumber = 590;
  inline const ::pb::Emc_Io_Plugin_Call& io_plugin_call() const;
  inline ::pb::Emc_Io_Plugin_Call* mutable_io_plugin_call();
  inline ::pb::Emc_Io_Plugin_Call* release_io_plugin_call();
  inline void set_allocated_io_plugin_call(::pb::Emc_Io_Plugin_Call* io_plugin_call);

  // optional bytes pru_firmware = 2048;
  inline bool has_pru_firmware() const;
  inline void clear_pru_firmware();
  static const int kPruFirmwareFieldNumber = 2048;
  inline const ::std::string& pru_firmware() const;
  inline void set_pru_firmware(const ::std::string& value);
  inline void set_pru_firmware(const char* value);
  inline void set_pru_firmware(const void* value, size_t size);
  inline ::std::string* mutable_pru_firmware();
  inline ::std::string* release_pru_firmware();
  inline void set_allocated_pru_firmware(::std::string* pru_firmware);

  // optional bytes mesa_5i20_firmware = 3000;
  inline bool has_mesa_5i20_firmware() const;
  inline void clear_mesa_5i20_firmware();
  static const int kMesa5I20FirmwareFieldNumber = 3000;
  inline const ::std::string& mesa_5i20_firmware() const;
  inline void set_mesa_5i20_firmware(const ::std::string& value);
  inline void set_mesa_5i20_firmware(const char* value);
  inline void set_mesa_5i20_firmware(const void* value, size_t size);
  inline ::std::string* mutable_mesa_5i20_firmware();
  inline ::std::string* release_mesa_5i20_firmware();
  inline void set_allocated_mesa_5i20_firmware(::std::string* mesa_5i20_firmware);

  // optional .pb.Test1 test1 = 5001;
  inline bool has_test1() const;
  inline void clear_test1();
  static const int kTest1FieldNumber = 5001;
  inline const ::pb::Test1& test1() const;
  inline ::pb::Test1* mutable_test1();
  inline ::pb::Test1* release_test1();
  inline void set_allocated_test1(::pb::Test1* test1);

  // optional .pb.Test2 test2 = 5002;
  inline bool has_test2() const;
  inline void clear_test2();
  static const int kTest2FieldNumber = 5002;
  inline const ::pb::Test2& test2() const;
  inline ::pb::Test2* mutable_test2();
  inline ::pb::Test2* release_test2();
  inline void set_allocated_test2(::pb::Test2* test2);

  // optional .pb.Test3 test3 = 5003;
  inline bool has_test3() const;
  inline void clear_test3();
  static const int kTest3FieldNumber = 5003;
  inline const ::pb::Test3& test3() const;
  inline ::pb::Test3* mutable_test3();
  inline ::pb::Test3* release_test3();
  inline void set_allocated_test3(::pb::Test3* test3);

  // @@protoc_insertion_point(class_scope:pb.Container)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_motcmd();
  inline void clear_has_motcmd();
  inline void set_has_motstat();
  inline void clear_has_motstat();
  inline void set_has_legacy_motcmd();
  inline void clear_has_legacy_motcmd();
  inline void set_has_legacy_motstat();
  inline void clear_has_legacy_motstat();
  inline void set_has_rtapi_message();
  inline void clear_has_rtapi_message();
  inline void set_has_task_reply();
  inline void clear_has_task_reply();
  inline void set_has_ticket_update();
  inline void clear_has_ticket_update();
  inline void set_has_syslog();
  inline void clear_has_syslog();
  inline void set_has_legacy_nml();
  inline void clear_has_legacy_nml();
  inline void set_has_legacy_motconfig();
  inline void clear_has_legacy_motconfig();
  inline void set_has_tv_sec();
  inline void clear_has_tv_sec();
  inline void set_has_tv_nsec();
  inline void clear_has_tv_nsec();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_reply_required();
  inline void clear_has_reply_required();
  inline void set_has_rsvp();
  inline void clear_has_rsvp();
  inline void set_has_in_reply_to();
  inline void clear_has_in_reply_to();
  inline void set_has_rcs_status();
  inline void clear_has_rcs_status();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_reply_serial();
  inline void clear_has_reply_serial();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_reply_ticket();
  inline void clear_has_reply_ticket();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_trace();
  inline void clear_has_trace();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_rtapicmd();
  inline void clear_has_rtapicmd();
  inline void set_has_ascii();
  inline void clear_has_ascii();
  inline void set_has_unicode();
  inline void clear_has_unicode();
  inline void set_has_gcode();
  inline void clear_has_gcode();
  inline void set_has_python();
  inline void clear_has_python();
  inline void set_has_pickle();
  inline void clear_has_pickle();
  inline void set_has_tcl();
  inline void clear_has_tcl();
  inline void set_has_xml();
  inline void clear_has_xml();
  inline void set_has_json();
  inline void clear_has_json();
  inline void set_has_jpeg();
  inline void clear_has_jpeg();
  inline void set_has_png();
  inline void clear_has_png();
  inline void set_has_tiff();
  inline void clear_has_tiff();
  inline void set_has_postscript();
  inline void clear_has_postscript();
  inline void set_has_svg();
  inline void clear_has_svg();
  inline void set_has_wou();
  inline void clear_has_wou();
  inline void set_has_log_message();
  inline void clear_has_log_message();
  inline void set_has_tpexecute();
  inline void clear_has_tpexecute();
  inline void set_has_tpblockdelete();
  inline void clear_has_tpblockdelete();
  inline void set_has_tpoptionalstop();
  inline void clear_has_tpoptionalstop();
  inline void set_has_tpopen();
  inline void clear_has_tpopen();
  inline void set_has_taskplan_reply();
  inline void clear_has_taskplan_reply();
  inline void set_has_traj_set_g5x();
  inline void clear_has_traj_set_g5x();
  inline void set_has_traj_set_g92();
  inline void clear_has_traj_set_g92();
  inline void set_has_traj_set_rotation();
  inline void clear_has_traj_set_rotation();
  inline void set_has_traj_linear_move();
  inline void clear_has_traj_linear_move();
  inline void set_has_traj_probe();
  inline void clear_has_traj_probe();
  inline void set_has_traj_circular_move();
  inline void clear_has_traj_circular_move();
  inline void set_has_traj_rigid_tap();
  inline void clear_has_traj_rigid_tap();
  inline void set_has_traj_set_term_cond();
  inline void clear_has_traj_set_term_cond();
  inline void set_has_traj_set_spindlesync();
  inline void clear_has_traj_set_spindlesync();
  inline void set_has_traj_delay();
  inline void clear_has_traj_delay();
  inline void set_has_spindle_on();
  inline void clear_has_spindle_on();
  inline void set_has_spindle_speed();
  inline void clear_has_spindle_speed();
  inline void set_has_spindle_orient();
  inline void clear_has_spindle_orient();
  inline void set_has_spindle_wait_orient_complete();
  inline void clear_has_spindle_wait_orient_complete();
  inline void set_has_tool_set_offet();
  inline void clear_has_tool_set_offet();
  inline void set_has_traj_set_offset();
  inline void clear_has_traj_set_offset();
  inline void set_has_tool_prepare();
  inline void clear_has_tool_prepare();
  inline void set_has_tool_set_number();
  inline void clear_has_tool_set_number();
  inline void set_has_traj_set_fo_enable();
  inline void clear_has_traj_set_fo_enable();
  inline void set_has_traj_set_so_enable();
  inline void clear_has_traj_set_so_enable();
  inline void set_has_traj_set_fh_enable();
  inline void clear_has_traj_set_fh_enable();
  inline void set_has_motion_adaptive();
  inline void clear_has_motion_adaptive();
  inline void set_has_operator_display();
  inline void clear_has_operator_display();
  inline void set_has_operator_text();
  inline void clear_has_operator_text();
  inline void set_has_operator_error();
  inline void clear_has_operator_error();
  inline void set_has_motion_set_dout();
  inline void clear_has_motion_set_dout();
  inline void set_has_motion_set_aout();
  inline void clear_has_motion_set_aout();
  inline void set_has_aux_input_wait();
  inline void clear_has_aux_input_wait();
  inline void set_has_exec_plugin_call();
  inline void clear_has_exec_plugin_call();
  inline void set_has_io_plugin_call();
  inline void clear_has_io_plugin_call();
  inline void set_has_pru_firmware();
  inline void clear_has_pru_firmware();
  inline void set_has_mesa_5i20_firmware();
  inline void clear_has_mesa_5i20_firmware();
  inline void set_has_test1();
  inline void clear_has_test1();
  inline void set_has_test2();
  inline void clear_has_test2();
  inline void set_has_test3();
  inline void clear_has_test3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::MotionCommand* motcmd_;
  ::pb::MotionStatus* motstat_;
  ::std::string* legacy_motcmd_;
  ::std::string* legacy_motstat_;
  ::pb::RTAPI_Message* rtapi_message_;
  int type_;
  ::google::protobuf::int32 tv_sec_;
  ::pb::TaskReply* task_reply_;
  ::pb::TicketUpdate* ticket_update_;
  ::std::string* syslog_;
  ::std::string* legacy_nml_;
  ::std::string* legacy_motconfig_;
  ::std::string* topic_;
  ::google::protobuf::int32 tv_nsec_;
  ::google::protobuf::int32 rsvp_;
  int in_reply_to_;
  int rcs_status_;
  int status_;
  ::google::protobuf::int32 serial_;
  ::google::protobuf::int32 reply_serial_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int32 reply_ticket_;
  bool reply_required_;
  bool trace_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 credit_;
  ::std::string* name_;
  ::google::protobuf::int32 line_number_;
  ::google::protobuf::int32 retcode_;
  ::google::protobuf::RepeatedPtrField< ::std::string> note_;
  ::pb::AnError* error_;
  ::std::string* uuid_;
  ::pb::Originator* origin_;
  ::pb::RTAPICommand* rtapicmd_;
  ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement > service_announcement_;
  ::google::protobuf::RepeatedPtrField< ::pb::Component > comp_;
  ::google::protobuf::RepeatedPtrField< ::pb::Pin > pin_;
  ::google::protobuf::RepeatedPtrField< ::pb::Signal > signal_;
  ::google::protobuf::RepeatedPtrField< ::pb::Param > param_;
  ::google::protobuf::RepeatedPtrField< ::pb::Thread > thread_;
  ::google::protobuf::RepeatedPtrField< ::pb::Ring > ring_;
  ::google::protobuf::RepeatedPtrField< ::pb::Group > group_;
  ::google::protobuf::RepeatedPtrField< ::pb::Member > member_;
  ::google::protobuf::RepeatedPtrField< ::pb::Function > function_;
  ::std::string* ascii_;
  ::std::string* unicode_;
  ::std::string* gcode_;
  ::std::string* python_;
  ::std::string* pickle_;
  ::std::string* tcl_;
  ::std::string* xml_;
  ::std::string* json_;
  ::std::string* jpeg_;
  ::std::string* png_;
  ::std::string* tiff_;
  ::std::string* postscript_;
  ::std::string* svg_;
  ::std::string* wou_;
  ::pb::LogMessage* log_message_;
  ::pb::TaskPlanExecute* tpexecute_;
  ::pb::TaskPlanBlockDelete* tpblockdelete_;
  ::pb::TaskPlanOptionalStop* tpoptionalstop_;
  ::pb::TaskPlanOpen* tpopen_;
  ::pb::TaskPlanReply* taskplan_reply_;
  ::pb::Emc_Traj_Set_G5x* traj_set_g5x_;
  ::pb::Emc_Traj_Set_G92* traj_set_g92_;
  ::pb::Emc_Traj_Set_Rotation* traj_set_rotation_;
  ::pb::Emc_Traj_Linear_Move* traj_linear_move_;
  ::pb::Emc_Traj_Probe* traj_probe_;
  ::pb::Emc_Traj_Circular_Move* traj_circular_move_;
  ::pb::Emc_Traj_Rigid_Tap* traj_rigid_tap_;
  ::pb::Emc_Traj_Set_Term_Cond* traj_set_term_cond_;
  ::pb::Emc_Traj_Set_Spindlesync* traj_set_spindlesync_;
  ::pb::Emc_Traj_Delay* traj_delay_;
  ::pb::Emc_Spindle_On* spindle_on_;
  ::pb::Emc_Spindle_Speed* spindle_speed_;
  ::pb::Emc_Spindle_Orient* spindle_orient_;
  ::pb::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete_;
  ::pb::Emc_Tool_Set_Offset* tool_set_offet_;
  ::pb::Emc_Traj_Set_Offset* traj_set_offset_;
  ::pb::Emc_Tool_Prepare* tool_prepare_;
  ::pb::Emc_Tool_Set_Number* tool_set_number_;
  ::pb::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable_;
  ::pb::Emc_Traj_Set_So_Enable* traj_set_so_enable_;
  ::pb::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable_;
  ::pb::Emc_Motion_Adaptive* motion_adaptive_;
  ::pb::Emc_Operator_Display* operator_display_;
  ::pb::Emc_Operator_Text* operator_text_;
  ::pb::Emc_Operator_Error* operator_error_;
  ::pb::Emc_Motion_Set_Dout* motion_set_dout_;
  ::pb::Emc_Motion_Set_Aout* motion_set_aout_;
  ::pb::Emc_Aux_Input_Wait* aux_input_wait_;
  ::pb::Emc_Exec_Plugin_Ca1l* exec_plugin_call_;
  ::pb::Emc_Io_Plugin_Call* io_plugin_call_;
  ::std::string* pru_firmware_;
  ::std::string* mesa_5i20_firmware_;
  ::pb::Test1* test1_;
  ::pb::Test2* test2_;
  ::pb::Test3* test3_;
  ::google::protobuf::int32 instance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(100 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// ===================================================================


// ===================================================================

// Container

// required .pb.ContainerType type = 1;
inline bool Container::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_type() {
  type_ = 3;
  clear_has_type();
}
inline ::pb::ContainerType Container::type() const {
  return static_cast< ::pb::ContainerType >(type_);
}
inline void Container::set_type(::pb::ContainerType value) {
  assert(::pb::ContainerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .pb.MotionCommand motcmd = 9;
inline bool Container::has_motcmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_motcmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_motcmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_motcmd() {
  if (motcmd_ != NULL) motcmd_->::pb::MotionCommand::Clear();
  clear_has_motcmd();
}
inline const ::pb::MotionCommand& Container::motcmd() const {
  return motcmd_ != NULL ? *motcmd_ : *default_instance_->motcmd_;
}
inline ::pb::MotionCommand* Container::mutable_motcmd() {
  set_has_motcmd();
  if (motcmd_ == NULL) motcmd_ = new ::pb::MotionCommand;
  return motcmd_;
}
inline ::pb::MotionCommand* Container::release_motcmd() {
  clear_has_motcmd();
  ::pb::MotionCommand* temp = motcmd_;
  motcmd_ = NULL;
  return temp;
}
inline void Container::set_allocated_motcmd(::pb::MotionCommand* motcmd) {
  delete motcmd_;
  motcmd_ = motcmd;
  if (motcmd) {
    set_has_motcmd();
  } else {
    clear_has_motcmd();
  }
}

// optional .pb.MotionStatus motstat = 10;
inline bool Container::has_motstat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_motstat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_motstat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_motstat() {
  if (motstat_ != NULL) motstat_->::pb::MotionStatus::Clear();
  clear_has_motstat();
}
inline const ::pb::MotionStatus& Container::motstat() const {
  return motstat_ != NULL ? *motstat_ : *default_instance_->motstat_;
}
inline ::pb::MotionStatus* Container::mutable_motstat() {
  set_has_motstat();
  if (motstat_ == NULL) motstat_ = new ::pb::MotionStatus;
  return motstat_;
}
inline ::pb::MotionStatus* Container::release_motstat() {
  clear_has_motstat();
  ::pb::MotionStatus* temp = motstat_;
  motstat_ = NULL;
  return temp;
}
inline void Container::set_allocated_motstat(::pb::MotionStatus* motstat) {
  delete motstat_;
  motstat_ = motstat;
  if (motstat) {
    set_has_motstat();
  } else {
    clear_has_motstat();
  }
}

// optional bytes legacy_motcmd = 11;
inline bool Container::has_legacy_motcmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_legacy_motcmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_legacy_motcmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_legacy_motcmd() {
  if (legacy_motcmd_ != &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_->clear();
  }
  clear_has_legacy_motcmd();
}
inline const ::std::string& Container::legacy_motcmd() const {
  return *legacy_motcmd_;
}
inline void Container::set_legacy_motcmd(const ::std::string& value) {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  legacy_motcmd_->assign(value);
}
inline void Container::set_legacy_motcmd(const char* value) {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  legacy_motcmd_->assign(value);
}
inline void Container::set_legacy_motcmd(const void* value, size_t size) {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  legacy_motcmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_motcmd() {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  return legacy_motcmd_;
}
inline ::std::string* Container::release_legacy_motcmd() {
  clear_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_motcmd_;
    legacy_motcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_legacy_motcmd(::std::string* legacy_motcmd) {
  if (legacy_motcmd_ != &::google::protobuf::internal::kEmptyString) {
    delete legacy_motcmd_;
  }
  if (legacy_motcmd) {
    set_has_legacy_motcmd();
    legacy_motcmd_ = legacy_motcmd;
  } else {
    clear_has_legacy_motcmd();
    legacy_motcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes legacy_motstat = 12;
inline bool Container::has_legacy_motstat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_legacy_motstat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_legacy_motstat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_legacy_motstat() {
  if (legacy_motstat_ != &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_->clear();
  }
  clear_has_legacy_motstat();
}
inline const ::std::string& Container::legacy_motstat() const {
  return *legacy_motstat_;
}
inline void Container::set_legacy_motstat(const ::std::string& value) {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  legacy_motstat_->assign(value);
}
inline void Container::set_legacy_motstat(const char* value) {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  legacy_motstat_->assign(value);
}
inline void Container::set_legacy_motstat(const void* value, size_t size) {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  legacy_motstat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_motstat() {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  return legacy_motstat_;
}
inline ::std::string* Container::release_legacy_motstat() {
  clear_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_motstat_;
    legacy_motstat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_legacy_motstat(::std::string* legacy_motstat) {
  if (legacy_motstat_ != &::google::protobuf::internal::kEmptyString) {
    delete legacy_motstat_;
  }
  if (legacy_motstat) {
    set_has_legacy_motstat();
    legacy_motstat_ = legacy_motstat;
  } else {
    clear_has_legacy_motstat();
    legacy_motstat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.RTAPI_Message rtapi_message = 13;
inline bool Container::has_rtapi_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_rtapi_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_rtapi_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_rtapi_message() {
  if (rtapi_message_ != NULL) rtapi_message_->::pb::RTAPI_Message::Clear();
  clear_has_rtapi_message();
}
inline const ::pb::RTAPI_Message& Container::rtapi_message() const {
  return rtapi_message_ != NULL ? *rtapi_message_ : *default_instance_->rtapi_message_;
}
inline ::pb::RTAPI_Message* Container::mutable_rtapi_message() {
  set_has_rtapi_message();
  if (rtapi_message_ == NULL) rtapi_message_ = new ::pb::RTAPI_Message;
  return rtapi_message_;
}
inline ::pb::RTAPI_Message* Container::release_rtapi_message() {
  clear_has_rtapi_message();
  ::pb::RTAPI_Message* temp = rtapi_message_;
  rtapi_message_ = NULL;
  return temp;
}
inline void Container::set_allocated_rtapi_message(::pb::RTAPI_Message* rtapi_message) {
  delete rtapi_message_;
  rtapi_message_ = rtapi_message;
  if (rtapi_message) {
    set_has_rtapi_message();
  } else {
    clear_has_rtapi_message();
  }
}

// optional .pb.TaskReply task_reply = 14;
inline bool Container::has_task_reply() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Container::set_has_task_reply() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Container::clear_has_task_reply() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Container::clear_task_reply() {
  if (task_reply_ != NULL) task_reply_->::pb::TaskReply::Clear();
  clear_has_task_reply();
}
inline const ::pb::TaskReply& Container::task_reply() const {
  return task_reply_ != NULL ? *task_reply_ : *default_instance_->task_reply_;
}
inline ::pb::TaskReply* Container::mutable_task_reply() {
  set_has_task_reply();
  if (task_reply_ == NULL) task_reply_ = new ::pb::TaskReply;
  return task_reply_;
}
inline ::pb::TaskReply* Container::release_task_reply() {
  clear_has_task_reply();
  ::pb::TaskReply* temp = task_reply_;
  task_reply_ = NULL;
  return temp;
}
inline void Container::set_allocated_task_reply(::pb::TaskReply* task_reply) {
  delete task_reply_;
  task_reply_ = task_reply;
  if (task_reply) {
    set_has_task_reply();
  } else {
    clear_has_task_reply();
  }
}

// optional .pb.TicketUpdate ticket_update = 15;
inline bool Container::has_ticket_update() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Container::set_has_ticket_update() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Container::clear_has_ticket_update() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Container::clear_ticket_update() {
  if (ticket_update_ != NULL) ticket_update_->::pb::TicketUpdate::Clear();
  clear_has_ticket_update();
}
inline const ::pb::TicketUpdate& Container::ticket_update() const {
  return ticket_update_ != NULL ? *ticket_update_ : *default_instance_->ticket_update_;
}
inline ::pb::TicketUpdate* Container::mutable_ticket_update() {
  set_has_ticket_update();
  if (ticket_update_ == NULL) ticket_update_ = new ::pb::TicketUpdate;
  return ticket_update_;
}
inline ::pb::TicketUpdate* Container::release_ticket_update() {
  clear_has_ticket_update();
  ::pb::TicketUpdate* temp = ticket_update_;
  ticket_update_ = NULL;
  return temp;
}
inline void Container::set_allocated_ticket_update(::pb::TicketUpdate* ticket_update) {
  delete ticket_update_;
  ticket_update_ = ticket_update;
  if (ticket_update) {
    set_has_ticket_update();
  } else {
    clear_has_ticket_update();
  }
}

// optional bytes syslog = 18;
inline bool Container::has_syslog() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Container::set_has_syslog() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Container::clear_has_syslog() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Container::clear_syslog() {
  if (syslog_ != &::google::protobuf::internal::kEmptyString) {
    syslog_->clear();
  }
  clear_has_syslog();
}
inline const ::std::string& Container::syslog() const {
  return *syslog_;
}
inline void Container::set_syslog(const ::std::string& value) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(value);
}
inline void Container::set_syslog(const char* value) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(value);
}
inline void Container::set_syslog(const void* value, size_t size) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_syslog() {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  return syslog_;
}
inline ::std::string* Container::release_syslog() {
  clear_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = syslog_;
    syslog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_syslog(::std::string* syslog) {
  if (syslog_ != &::google::protobuf::internal::kEmptyString) {
    delete syslog_;
  }
  if (syslog) {
    set_has_syslog();
    syslog_ = syslog;
  } else {
    clear_has_syslog();
    syslog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes legacy_nml = 19;
inline bool Container::has_legacy_nml() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Container::set_has_legacy_nml() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Container::clear_has_legacy_nml() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Container::clear_legacy_nml() {
  if (legacy_nml_ != &::google::protobuf::internal::kEmptyString) {
    legacy_nml_->clear();
  }
  clear_has_legacy_nml();
}
inline const ::std::string& Container::legacy_nml() const {
  return *legacy_nml_;
}
inline void Container::set_legacy_nml(const ::std::string& value) {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  legacy_nml_->assign(value);
}
inline void Container::set_legacy_nml(const char* value) {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  legacy_nml_->assign(value);
}
inline void Container::set_legacy_nml(const void* value, size_t size) {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  legacy_nml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_nml() {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  return legacy_nml_;
}
inline ::std::string* Container::release_legacy_nml() {
  clear_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_nml_;
    legacy_nml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_legacy_nml(::std::string* legacy_nml) {
  if (legacy_nml_ != &::google::protobuf::internal::kEmptyString) {
    delete legacy_nml_;
  }
  if (legacy_nml) {
    set_has_legacy_nml();
    legacy_nml_ = legacy_nml;
  } else {
    clear_has_legacy_nml();
    legacy_nml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes legacy_motconfig = 20;
inline bool Container::has_legacy_motconfig() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Container::set_has_legacy_motconfig() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Container::clear_has_legacy_motconfig() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Container::clear_legacy_motconfig() {
  if (legacy_motconfig_ != &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_->clear();
  }
  clear_has_legacy_motconfig();
}
inline const ::std::string& Container::legacy_motconfig() const {
  return *legacy_motconfig_;
}
inline void Container::set_legacy_motconfig(const ::std::string& value) {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  legacy_motconfig_->assign(value);
}
inline void Container::set_legacy_motconfig(const char* value) {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  legacy_motconfig_->assign(value);
}
inline void Container::set_legacy_motconfig(const void* value, size_t size) {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  legacy_motconfig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_motconfig() {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  return legacy_motconfig_;
}
inline ::std::string* Container::release_legacy_motconfig() {
  clear_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_motconfig_;
    legacy_motconfig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_legacy_motconfig(::std::string* legacy_motconfig) {
  if (legacy_motconfig_ != &::google::protobuf::internal::kEmptyString) {
    delete legacy_motconfig_;
  }
  if (legacy_motconfig) {
    set_has_legacy_motconfig();
    legacy_motconfig_ = legacy_motconfig;
  } else {
    clear_has_legacy_motconfig();
    legacy_motconfig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 tv_sec = 21;
inline bool Container::has_tv_sec() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Container::set_has_tv_sec() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Container::clear_has_tv_sec() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Container::clear_tv_sec() {
  tv_sec_ = 0;
  clear_has_tv_sec();
}
inline ::google::protobuf::int32 Container::tv_sec() const {
  return tv_sec_;
}
inline void Container::set_tv_sec(::google::protobuf::int32 value) {
  set_has_tv_sec();
  tv_sec_ = value;
}

// optional int32 tv_nsec = 22;
inline bool Container::has_tv_nsec() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Container::set_has_tv_nsec() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Container::clear_has_tv_nsec() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Container::clear_tv_nsec() {
  tv_nsec_ = 0;
  clear_has_tv_nsec();
}
inline ::google::protobuf::int32 Container::tv_nsec() const {
  return tv_nsec_;
}
inline void Container::set_tv_nsec(::google::protobuf::int32 value) {
  set_has_tv_nsec();
  tv_nsec_ = value;
}

// optional string topic = 23;
inline bool Container::has_topic() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Container::set_has_topic() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Container::clear_has_topic() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Container::clear_topic() {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Container::topic() const {
  return *topic_;
}
inline void Container::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Container::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Container::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  return topic_;
}
inline ::std::string* Container::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool reply_required = 24;
inline bool Container::has_reply_required() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Container::set_has_reply_required() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Container::clear_has_reply_required() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Container::clear_reply_required() {
  reply_required_ = false;
  clear_has_reply_required();
}
inline bool Container::reply_required() const {
  return reply_required_;
}
inline void Container::set_reply_required(bool value) {
  set_has_reply_required();
  reply_required_ = value;
}

// optional int32 rsvp = 30;
inline bool Container::has_rsvp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Container::set_has_rsvp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Container::clear_has_rsvp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Container::clear_rsvp() {
  rsvp_ = 0;
  clear_has_rsvp();
}
inline ::google::protobuf::int32 Container::rsvp() const {
  return rsvp_;
}
inline void Container::set_rsvp(::google::protobuf::int32 value) {
  set_has_rsvp();
  rsvp_ = value;
}

// optional .pb.ContainerType in_reply_to = 33;
inline bool Container::has_in_reply_to() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Container::set_has_in_reply_to() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Container::clear_has_in_reply_to() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Container::clear_in_reply_to() {
  in_reply_to_ = 3;
  clear_has_in_reply_to();
}
inline ::pb::ContainerType Container::in_reply_to() const {
  return static_cast< ::pb::ContainerType >(in_reply_to_);
}
inline void Container::set_in_reply_to(::pb::ContainerType value) {
  assert(::pb::ContainerType_IsValid(value));
  set_has_in_reply_to();
  in_reply_to_ = value;
}

// optional .pb.RCS_STATUS rcs_status = 35;
inline bool Container::has_rcs_status() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Container::set_has_rcs_status() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Container::clear_has_rcs_status() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Container::clear_rcs_status() {
  rcs_status_ = -1;
  clear_has_rcs_status();
}
inline ::pb::RCS_STATUS Container::rcs_status() const {
  return static_cast< ::pb::RCS_STATUS >(rcs_status_);
}
inline void Container::set_rcs_status(::pb::RCS_STATUS value) {
  assert(::pb::RCS_STATUS_IsValid(value));
  set_has_rcs_status();
  rcs_status_ = value;
}

// optional .pb.StatusType status = 40;
inline bool Container::has_status() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Container::set_has_status() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Container::clear_has_status() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Container::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::pb::StatusType Container::status() const {
  return static_cast< ::pb::StatusType >(status_);
}
inline void Container::set_status(::pb::StatusType value) {
  assert(::pb::StatusType_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 serial = 45;
inline bool Container::has_serial() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Container::set_has_serial() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Container::clear_has_serial() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Container::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 Container::serial() const {
  return serial_;
}
inline void Container::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// optional int32 reply_serial = 50;
inline bool Container::has_reply_serial() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Container::set_has_reply_serial() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Container::clear_has_reply_serial() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Container::clear_reply_serial() {
  reply_serial_ = 0;
  clear_has_reply_serial();
}
inline ::google::protobuf::int32 Container::reply_serial() const {
  return reply_serial_;
}
inline void Container::set_reply_serial(::google::protobuf::int32 value) {
  set_has_reply_serial();
  reply_serial_ = value;
}

// optional int32 ticket = 55;
inline bool Container::has_ticket() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Container::set_has_ticket() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Container::clear_has_ticket() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Container::clear_ticket() {
  ticket_ = 0;
  clear_has_ticket();
}
inline ::google::protobuf::int32 Container::ticket() const {
  return ticket_;
}
inline void Container::set_ticket(::google::protobuf::int32 value) {
  set_has_ticket();
  ticket_ = value;
}

// optional int32 reply_ticket = 60;
inline bool Container::has_reply_ticket() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Container::set_has_reply_ticket() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Container::clear_has_reply_ticket() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Container::clear_reply_ticket() {
  reply_ticket_ = 0;
  clear_has_reply_ticket();
}
inline ::google::protobuf::int32 Container::reply_ticket() const {
  return reply_ticket_;
}
inline void Container::set_reply_ticket(::google::protobuf::int32 value) {
  set_has_reply_ticket();
  reply_ticket_ = value;
}

// optional int32 sequence = 62;
inline bool Container::has_sequence() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Container::set_has_sequence() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Container::clear_has_sequence() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Container::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 Container::sequence() const {
  return sequence_;
}
inline void Container::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int32 credit = 65;
inline bool Container::has_credit() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Container::set_has_credit() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Container::clear_has_credit() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Container::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline ::google::protobuf::int32 Container::credit() const {
  return credit_;
}
inline void Container::set_credit(::google::protobuf::int32 value) {
  set_has_credit();
  credit_ = value;
}

// optional int32 line_number = 66;
inline bool Container::has_line_number() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Container::set_has_line_number() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Container::clear_has_line_number() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Container::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 Container::line_number() const {
  return line_number_;
}
inline void Container::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
}

// optional string name = 67;
inline bool Container::has_name() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Container::set_has_name() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Container::clear_has_name() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Container::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Container::name() const {
  return *name_;
}
inline void Container::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Container::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Container::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Container::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string note = 68;
inline int Container::note_size() const {
  return note_.size();
}
inline void Container::clear_note() {
  note_.Clear();
}
inline const ::std::string& Container::note(int index) const {
  return note_.Get(index);
}
inline ::std::string* Container::mutable_note(int index) {
  return note_.Mutable(index);
}
inline void Container::set_note(int index, const ::std::string& value) {
  note_.Mutable(index)->assign(value);
}
inline void Container::set_note(int index, const char* value) {
  note_.Mutable(index)->assign(value);
}
inline void Container::set_note(int index, const char* value, size_t size) {
  note_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::add_note() {
  return note_.Add();
}
inline void Container::add_note(const ::std::string& value) {
  note_.Add()->assign(value);
}
inline void Container::add_note(const char* value) {
  note_.Add()->assign(value);
}
inline void Container::add_note(const char* value, size_t size) {
  note_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Container::note() const {
  return note_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Container::mutable_note() {
  return &note_;
}

// optional int32 retcode = 69;
inline bool Container::has_retcode() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Container::set_has_retcode() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Container::clear_has_retcode() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Container::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 Container::retcode() const {
  return retcode_;
}
inline void Container::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional .pb.AnError error = 70;
inline bool Container::has_error() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Container::set_has_error() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Container::clear_has_error() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Container::clear_error() {
  if (error_ != NULL) error_->::pb::AnError::Clear();
  clear_has_error();
}
inline const ::pb::AnError& Container::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::pb::AnError* Container::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::pb::AnError;
  return error_;
}
inline ::pb::AnError* Container::release_error() {
  clear_has_error();
  ::pb::AnError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Container::set_allocated_error(::pb::AnError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// optional bytes uuid = 72;
inline bool Container::has_uuid() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Container::set_has_uuid() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Container::clear_has_uuid() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Container::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Container::uuid() const {
  return *uuid_;
}
inline void Container::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Container::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Container::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Container::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool trace = 75;
inline bool Container::has_trace() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Container::set_has_trace() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Container::clear_has_trace() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Container::clear_trace() {
  trace_ = false;
  clear_has_trace();
}
inline bool Container::trace() const {
  return trace_;
}
inline void Container::set_trace(bool value) {
  set_has_trace();
  trace_ = value;
}

// optional int32 instance = 77;
inline bool Container::has_instance() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Container::set_has_instance() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Container::clear_has_instance() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Container::clear_instance() {
  instance_ = 0;
  clear_has_instance();
}
inline ::google::protobuf::int32 Container::instance() const {
  return instance_;
}
inline void Container::set_instance(::google::protobuf::int32 value) {
  set_has_instance();
  instance_ = value;
}

// optional .pb.Originator origin = 80;
inline bool Container::has_origin() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Container::set_has_origin() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Container::clear_has_origin() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Container::clear_origin() {
  if (origin_ != NULL) origin_->::pb::Originator::Clear();
  clear_has_origin();
}
inline const ::pb::Originator& Container::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::pb::Originator* Container::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::pb::Originator;
  return origin_;
}
inline ::pb::Originator* Container::release_origin() {
  clear_has_origin();
  ::pb::Originator* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void Container::set_allocated_origin(::pb::Originator* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// optional .pb.RTAPICommand rtapicmd = 86;
inline bool Container::has_rtapicmd() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Container::set_has_rtapicmd() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Container::clear_has_rtapicmd() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Container::clear_rtapicmd() {
  if (rtapicmd_ != NULL) rtapicmd_->::pb::RTAPICommand::Clear();
  clear_has_rtapicmd();
}
inline const ::pb::RTAPICommand& Container::rtapicmd() const {
  return rtapicmd_ != NULL ? *rtapicmd_ : *default_instance_->rtapicmd_;
}
inline ::pb::RTAPICommand* Container::mutable_rtapicmd() {
  set_has_rtapicmd();
  if (rtapicmd_ == NULL) rtapicmd_ = new ::pb::RTAPICommand;
  return rtapicmd_;
}
inline ::pb::RTAPICommand* Container::release_rtapicmd() {
  clear_has_rtapicmd();
  ::pb::RTAPICommand* temp = rtapicmd_;
  rtapicmd_ = NULL;
  return temp;
}
inline void Container::set_allocated_rtapicmd(::pb::RTAPICommand* rtapicmd) {
  delete rtapicmd_;
  rtapicmd_ = rtapicmd;
  if (rtapicmd) {
    set_has_rtapicmd();
  } else {
    clear_has_rtapicmd();
  }
}

// repeated .pb.ServiceAnnouncement service_announcement = 88;
inline int Container::service_announcement_size() const {
  return service_announcement_.size();
}
inline void Container::clear_service_announcement() {
  service_announcement_.Clear();
}
inline const ::pb::ServiceAnnouncement& Container::service_announcement(int index) const {
  return service_announcement_.Get(index);
}
inline ::pb::ServiceAnnouncement* Container::mutable_service_announcement(int index) {
  return service_announcement_.Mutable(index);
}
inline ::pb::ServiceAnnouncement* Container::add_service_announcement() {
  return service_announcement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >&
Container::service_announcement() const {
  return service_announcement_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >*
Container::mutable_service_announcement() {
  return &service_announcement_;
}

// repeated .pb.Component comp = 100;
inline int Container::comp_size() const {
  return comp_.size();
}
inline void Container::clear_comp() {
  comp_.Clear();
}
inline const ::pb::Component& Container::comp(int index) const {
  return comp_.Get(index);
}
inline ::pb::Component* Container::mutable_comp(int index) {
  return comp_.Mutable(index);
}
inline ::pb::Component* Container::add_comp() {
  return comp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Component >&
Container::comp() const {
  return comp_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Component >*
Container::mutable_comp() {
  return &comp_;
}

// repeated .pb.Pin pin = 2;
inline int Container::pin_size() const {
  return pin_.size();
}
inline void Container::clear_pin() {
  pin_.Clear();
}
inline const ::pb::Pin& Container::pin(int index) const {
  return pin_.Get(index);
}
inline ::pb::Pin* Container::mutable_pin(int index) {
  return pin_.Mutable(index);
}
inline ::pb::Pin* Container::add_pin() {
  return pin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Pin >&
Container::pin() const {
  return pin_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Pin >*
Container::mutable_pin() {
  return &pin_;
}

// repeated .pb.Signal signal = 3;
inline int Container::signal_size() const {
  return signal_.size();
}
inline void Container::clear_signal() {
  signal_.Clear();
}
inline const ::pb::Signal& Container::signal(int index) const {
  return signal_.Get(index);
}
inline ::pb::Signal* Container::mutable_signal(int index) {
  return signal_.Mutable(index);
}
inline ::pb::Signal* Container::add_signal() {
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Signal >&
Container::signal() const {
  return signal_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Signal >*
Container::mutable_signal() {
  return &signal_;
}

// repeated .pb.Param param = 103;
inline int Container::param_size() const {
  return param_.size();
}
inline void Container::clear_param() {
  param_.Clear();
}
inline const ::pb::Param& Container::param(int index) const {
  return param_.Get(index);
}
inline ::pb::Param* Container::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::pb::Param* Container::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Param >&
Container::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Param >*
Container::mutable_param() {
  return &param_;
}

// repeated .pb.Thread thread = 104;
inline int Container::thread_size() const {
  return thread_.size();
}
inline void Container::clear_thread() {
  thread_.Clear();
}
inline const ::pb::Thread& Container::thread(int index) const {
  return thread_.Get(index);
}
inline ::pb::Thread* Container::mutable_thread(int index) {
  return thread_.Mutable(index);
}
inline ::pb::Thread* Container::add_thread() {
  return thread_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Thread >&
Container::thread() const {
  return thread_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Thread >*
Container::mutable_thread() {
  return &thread_;
}

// repeated .pb.Ring ring = 105;
inline int Container::ring_size() const {
  return ring_.size();
}
inline void Container::clear_ring() {
  ring_.Clear();
}
inline const ::pb::Ring& Container::ring(int index) const {
  return ring_.Get(index);
}
inline ::pb::Ring* Container::mutable_ring(int index) {
  return ring_.Mutable(index);
}
inline ::pb::Ring* Container::add_ring() {
  return ring_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Ring >&
Container::ring() const {
  return ring_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Ring >*
Container::mutable_ring() {
  return &ring_;
}

// repeated .pb.Group group = 106;
inline int Container::group_size() const {
  return group_.size();
}
inline void Container::clear_group() {
  group_.Clear();
}
inline const ::pb::Group& Container::group(int index) const {
  return group_.Get(index);
}
inline ::pb::Group* Container::mutable_group(int index) {
  return group_.Mutable(index);
}
inline ::pb::Group* Container::add_group() {
  return group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Group >&
Container::group() const {
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Group >*
Container::mutable_group() {
  return &group_;
}

// repeated .pb.Member member = 107;
inline int Container::member_size() const {
  return member_.size();
}
inline void Container::clear_member() {
  member_.Clear();
}
inline const ::pb::Member& Container::member(int index) const {
  return member_.Get(index);
}
inline ::pb::Member* Container::mutable_member(int index) {
  return member_.Mutable(index);
}
inline ::pb::Member* Container::add_member() {
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Member >&
Container::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Member >*
Container::mutable_member() {
  return &member_;
}

// repeated .pb.Function function = 108;
inline int Container::function_size() const {
  return function_.size();
}
inline void Container::clear_function() {
  function_.Clear();
}
inline const ::pb::Function& Container::function(int index) const {
  return function_.Get(index);
}
inline ::pb::Function* Container::mutable_function(int index) {
  return function_.Mutable(index);
}
inline ::pb::Function* Container::add_function() {
  return function_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Function >&
Container::function() const {
  return function_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Function >*
Container::mutable_function() {
  return &function_;
}

// optional string ascii = 140;
inline bool Container::has_ascii() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Container::set_has_ascii() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Container::clear_has_ascii() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void Container::clear_ascii() {
  if (ascii_ != &::google::protobuf::internal::kEmptyString) {
    ascii_->clear();
  }
  clear_has_ascii();
}
inline const ::std::string& Container::ascii() const {
  return *ascii_;
}
inline void Container::set_ascii(const ::std::string& value) {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  ascii_->assign(value);
}
inline void Container::set_ascii(const char* value) {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  ascii_->assign(value);
}
inline void Container::set_ascii(const char* value, size_t size) {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  ascii_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_ascii() {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  return ascii_;
}
inline ::std::string* Container::release_ascii() {
  clear_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ascii_;
    ascii_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_ascii(::std::string* ascii) {
  if (ascii_ != &::google::protobuf::internal::kEmptyString) {
    delete ascii_;
  }
  if (ascii) {
    set_has_ascii();
    ascii_ = ascii;
  } else {
    clear_has_ascii();
    ascii_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes unicode = 141;
inline bool Container::has_unicode() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Container::set_has_unicode() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Container::clear_has_unicode() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void Container::clear_unicode() {
  if (unicode_ != &::google::protobuf::internal::kEmptyString) {
    unicode_->clear();
  }
  clear_has_unicode();
}
inline const ::std::string& Container::unicode() const {
  return *unicode_;
}
inline void Container::set_unicode(const ::std::string& value) {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  unicode_->assign(value);
}
inline void Container::set_unicode(const char* value) {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  unicode_->assign(value);
}
inline void Container::set_unicode(const void* value, size_t size) {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  unicode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_unicode() {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  return unicode_;
}
inline ::std::string* Container::release_unicode() {
  clear_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unicode_;
    unicode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_unicode(::std::string* unicode) {
  if (unicode_ != &::google::protobuf::internal::kEmptyString) {
    delete unicode_;
  }
  if (unicode) {
    set_has_unicode();
    unicode_ = unicode;
  } else {
    clear_has_unicode();
    unicode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gcode = 142;
inline bool Container::has_gcode() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Container::set_has_gcode() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Container::clear_has_gcode() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void Container::clear_gcode() {
  if (gcode_ != &::google::protobuf::internal::kEmptyString) {
    gcode_->clear();
  }
  clear_has_gcode();
}
inline const ::std::string& Container::gcode() const {
  return *gcode_;
}
inline void Container::set_gcode(const ::std::string& value) {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  gcode_->assign(value);
}
inline void Container::set_gcode(const char* value) {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  gcode_->assign(value);
}
inline void Container::set_gcode(const char* value, size_t size) {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  gcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_gcode() {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  return gcode_;
}
inline ::std::string* Container::release_gcode() {
  clear_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gcode_;
    gcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_gcode(::std::string* gcode) {
  if (gcode_ != &::google::protobuf::internal::kEmptyString) {
    delete gcode_;
  }
  if (gcode) {
    set_has_gcode();
    gcode_ = gcode;
  } else {
    clear_has_gcode();
    gcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string python = 143;
inline bool Container::has_python() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Container::set_has_python() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Container::clear_has_python() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Container::clear_python() {
  if (python_ != &::google::protobuf::internal::kEmptyString) {
    python_->clear();
  }
  clear_has_python();
}
inline const ::std::string& Container::python() const {
  return *python_;
}
inline void Container::set_python(const ::std::string& value) {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  python_->assign(value);
}
inline void Container::set_python(const char* value) {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  python_->assign(value);
}
inline void Container::set_python(const char* value, size_t size) {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  python_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_python() {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  return python_;
}
inline ::std::string* Container::release_python() {
  clear_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = python_;
    python_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_python(::std::string* python) {
  if (python_ != &::google::protobuf::internal::kEmptyString) {
    delete python_;
  }
  if (python) {
    set_has_python();
    python_ = python;
  } else {
    clear_has_python();
    python_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pickle = 144;
inline bool Container::has_pickle() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void Container::set_has_pickle() {
  _has_bits_[1] |= 0x00020000u;
}
inline void Container::clear_has_pickle() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void Container::clear_pickle() {
  if (pickle_ != &::google::protobuf::internal::kEmptyString) {
    pickle_->clear();
  }
  clear_has_pickle();
}
inline const ::std::string& Container::pickle() const {
  return *pickle_;
}
inline void Container::set_pickle(const ::std::string& value) {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  pickle_->assign(value);
}
inline void Container::set_pickle(const char* value) {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  pickle_->assign(value);
}
inline void Container::set_pickle(const void* value, size_t size) {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  pickle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_pickle() {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  return pickle_;
}
inline ::std::string* Container::release_pickle() {
  clear_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pickle_;
    pickle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_pickle(::std::string* pickle) {
  if (pickle_ != &::google::protobuf::internal::kEmptyString) {
    delete pickle_;
  }
  if (pickle) {
    set_has_pickle();
    pickle_ = pickle;
  } else {
    clear_has_pickle();
    pickle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcl = 145;
inline bool Container::has_tcl() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Container::set_has_tcl() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Container::clear_has_tcl() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void Container::clear_tcl() {
  if (tcl_ != &::google::protobuf::internal::kEmptyString) {
    tcl_->clear();
  }
  clear_has_tcl();
}
inline const ::std::string& Container::tcl() const {
  return *tcl_;
}
inline void Container::set_tcl(const ::std::string& value) {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  tcl_->assign(value);
}
inline void Container::set_tcl(const char* value) {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  tcl_->assign(value);
}
inline void Container::set_tcl(const char* value, size_t size) {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  tcl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_tcl() {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  return tcl_;
}
inline ::std::string* Container::release_tcl() {
  clear_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcl_;
    tcl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_tcl(::std::string* tcl) {
  if (tcl_ != &::google::protobuf::internal::kEmptyString) {
    delete tcl_;
  }
  if (tcl) {
    set_has_tcl();
    tcl_ = tcl;
  } else {
    clear_has_tcl();
    tcl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xml = 146;
inline bool Container::has_xml() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Container::set_has_xml() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Container::clear_has_xml() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void Container::clear_xml() {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    xml_->clear();
  }
  clear_has_xml();
}
inline const ::std::string& Container::xml() const {
  return *xml_;
}
inline void Container::set_xml(const ::std::string& value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void Container::set_xml(const char* value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void Container::set_xml(const char* value, size_t size) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_xml() {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  return xml_;
}
inline ::std::string* Container::release_xml() {
  clear_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xml_;
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_xml(::std::string* xml) {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    delete xml_;
  }
  if (xml) {
    set_has_xml();
    xml_ = xml;
  } else {
    clear_has_xml();
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string json = 147;
inline bool Container::has_json() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Container::set_has_json() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Container::clear_has_json() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void Container::clear_json() {
  if (json_ != &::google::protobuf::internal::kEmptyString) {
    json_->clear();
  }
  clear_has_json();
}
inline const ::std::string& Container::json() const {
  return *json_;
}
inline void Container::set_json(const ::std::string& value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  json_->assign(value);
}
inline void Container::set_json(const char* value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  json_->assign(value);
}
inline void Container::set_json(const char* value, size_t size) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  json_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_json() {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  return json_;
}
inline ::std::string* Container::release_json() {
  clear_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = json_;
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_json(::std::string* json) {
  if (json_ != &::google::protobuf::internal::kEmptyString) {
    delete json_;
  }
  if (json) {
    set_has_json();
    json_ = json;
  } else {
    clear_has_json();
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes jpeg = 148;
inline bool Container::has_jpeg() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Container::set_has_jpeg() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Container::clear_has_jpeg() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void Container::clear_jpeg() {
  if (jpeg_ != &::google::protobuf::internal::kEmptyString) {
    jpeg_->clear();
  }
  clear_has_jpeg();
}
inline const ::std::string& Container::jpeg() const {
  return *jpeg_;
}
inline void Container::set_jpeg(const ::std::string& value) {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  jpeg_->assign(value);
}
inline void Container::set_jpeg(const char* value) {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  jpeg_->assign(value);
}
inline void Container::set_jpeg(const void* value, size_t size) {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  jpeg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_jpeg() {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  return jpeg_;
}
inline ::std::string* Container::release_jpeg() {
  clear_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jpeg_;
    jpeg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_jpeg(::std::string* jpeg) {
  if (jpeg_ != &::google::protobuf::internal::kEmptyString) {
    delete jpeg_;
  }
  if (jpeg) {
    set_has_jpeg();
    jpeg_ = jpeg;
  } else {
    clear_has_jpeg();
    jpeg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes png = 149;
inline bool Container::has_png() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Container::set_has_png() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Container::clear_has_png() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void Container::clear_png() {
  if (png_ != &::google::protobuf::internal::kEmptyString) {
    png_->clear();
  }
  clear_has_png();
}
inline const ::std::string& Container::png() const {
  return *png_;
}
inline void Container::set_png(const ::std::string& value) {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  png_->assign(value);
}
inline void Container::set_png(const char* value) {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  png_->assign(value);
}
inline void Container::set_png(const void* value, size_t size) {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  png_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_png() {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  return png_;
}
inline ::std::string* Container::release_png() {
  clear_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = png_;
    png_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_png(::std::string* png) {
  if (png_ != &::google::protobuf::internal::kEmptyString) {
    delete png_;
  }
  if (png) {
    set_has_png();
    png_ = png;
  } else {
    clear_has_png();
    png_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes tiff = 150;
inline bool Container::has_tiff() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Container::set_has_tiff() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Container::clear_has_tiff() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void Container::clear_tiff() {
  if (tiff_ != &::google::protobuf::internal::kEmptyString) {
    tiff_->clear();
  }
  clear_has_tiff();
}
inline const ::std::string& Container::tiff() const {
  return *tiff_;
}
inline void Container::set_tiff(const ::std::string& value) {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  tiff_->assign(value);
}
inline void Container::set_tiff(const char* value) {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  tiff_->assign(value);
}
inline void Container::set_tiff(const void* value, size_t size) {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  tiff_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_tiff() {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  return tiff_;
}
inline ::std::string* Container::release_tiff() {
  clear_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tiff_;
    tiff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_tiff(::std::string* tiff) {
  if (tiff_ != &::google::protobuf::internal::kEmptyString) {
    delete tiff_;
  }
  if (tiff) {
    set_has_tiff();
    tiff_ = tiff;
  } else {
    clear_has_tiff();
    tiff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes postscript = 151;
inline bool Container::has_postscript() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Container::set_has_postscript() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Container::clear_has_postscript() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void Container::clear_postscript() {
  if (postscript_ != &::google::protobuf::internal::kEmptyString) {
    postscript_->clear();
  }
  clear_has_postscript();
}
inline const ::std::string& Container::postscript() const {
  return *postscript_;
}
inline void Container::set_postscript(const ::std::string& value) {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  postscript_->assign(value);
}
inline void Container::set_postscript(const char* value) {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  postscript_->assign(value);
}
inline void Container::set_postscript(const void* value, size_t size) {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  postscript_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_postscript() {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  return postscript_;
}
inline ::std::string* Container::release_postscript() {
  clear_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postscript_;
    postscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_postscript(::std::string* postscript) {
  if (postscript_ != &::google::protobuf::internal::kEmptyString) {
    delete postscript_;
  }
  if (postscript) {
    set_has_postscript();
    postscript_ = postscript;
  } else {
    clear_has_postscript();
    postscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes svg = 152;
inline bool Container::has_svg() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Container::set_has_svg() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Container::clear_has_svg() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void Container::clear_svg() {
  if (svg_ != &::google::protobuf::internal::kEmptyString) {
    svg_->clear();
  }
  clear_has_svg();
}
inline const ::std::string& Container::svg() const {
  return *svg_;
}
inline void Container::set_svg(const ::std::string& value) {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  svg_->assign(value);
}
inline void Container::set_svg(const char* value) {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  svg_->assign(value);
}
inline void Container::set_svg(const void* value, size_t size) {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  svg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_svg() {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  return svg_;
}
inline ::std::string* Container::release_svg() {
  clear_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svg_;
    svg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_svg(::std::string* svg) {
  if (svg_ != &::google::protobuf::internal::kEmptyString) {
    delete svg_;
  }
  if (svg) {
    set_has_svg();
    svg_ = svg;
  } else {
    clear_has_svg();
    svg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes wou = 160;
inline bool Container::has_wou() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Container::set_has_wou() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Container::clear_has_wou() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void Container::clear_wou() {
  if (wou_ != &::google::protobuf::internal::kEmptyString) {
    wou_->clear();
  }
  clear_has_wou();
}
inline const ::std::string& Container::wou() const {
  return *wou_;
}
inline void Container::set_wou(const ::std::string& value) {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  wou_->assign(value);
}
inline void Container::set_wou(const char* value) {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  wou_->assign(value);
}
inline void Container::set_wou(const void* value, size_t size) {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  wou_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_wou() {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  return wou_;
}
inline ::std::string* Container::release_wou() {
  clear_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wou_;
    wou_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_wou(::std::string* wou) {
  if (wou_ != &::google::protobuf::internal::kEmptyString) {
    delete wou_;
  }
  if (wou) {
    set_has_wou();
    wou_ = wou;
  } else {
    clear_has_wou();
    wou_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.LogMessage log_message = 87;
inline bool Container::has_log_message() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Container::set_has_log_message() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Container::clear_has_log_message() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Container::clear_log_message() {
  if (log_message_ != NULL) log_message_->::pb::LogMessage::Clear();
  clear_has_log_message();
}
inline const ::pb::LogMessage& Container::log_message() const {
  return log_message_ != NULL ? *log_message_ : *default_instance_->log_message_;
}
inline ::pb::LogMessage* Container::mutable_log_message() {
  set_has_log_message();
  if (log_message_ == NULL) log_message_ = new ::pb::LogMessage;
  return log_message_;
}
inline ::pb::LogMessage* Container::release_log_message() {
  clear_has_log_message();
  ::pb::LogMessage* temp = log_message_;
  log_message_ = NULL;
  return temp;
}
inline void Container::set_allocated_log_message(::pb::LogMessage* log_message) {
  delete log_message_;
  log_message_ = log_message;
  if (log_message) {
    set_has_log_message();
  } else {
    clear_has_log_message();
  }
}

// optional .pb.TaskPlanExecute tpexecute = 200;
inline bool Container::has_tpexecute() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Container::set_has_tpexecute() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Container::clear_has_tpexecute() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Container::clear_tpexecute() {
  if (tpexecute_ != NULL) tpexecute_->::pb::TaskPlanExecute::Clear();
  clear_has_tpexecute();
}
inline const ::pb::TaskPlanExecute& Container::tpexecute() const {
  return tpexecute_ != NULL ? *tpexecute_ : *default_instance_->tpexecute_;
}
inline ::pb::TaskPlanExecute* Container::mutable_tpexecute() {
  set_has_tpexecute();
  if (tpexecute_ == NULL) tpexecute_ = new ::pb::TaskPlanExecute;
  return tpexecute_;
}
inline ::pb::TaskPlanExecute* Container::release_tpexecute() {
  clear_has_tpexecute();
  ::pb::TaskPlanExecute* temp = tpexecute_;
  tpexecute_ = NULL;
  return temp;
}
inline void Container::set_allocated_tpexecute(::pb::TaskPlanExecute* tpexecute) {
  delete tpexecute_;
  tpexecute_ = tpexecute;
  if (tpexecute) {
    set_has_tpexecute();
  } else {
    clear_has_tpexecute();
  }
}

// optional .pb.TaskPlanBlockDelete tpblockdelete = 201;
inline bool Container::has_tpblockdelete() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void Container::set_has_tpblockdelete() {
  _has_bits_[1] |= 0x20000000u;
}
inline void Container::clear_has_tpblockdelete() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void Container::clear_tpblockdelete() {
  if (tpblockdelete_ != NULL) tpblockdelete_->::pb::TaskPlanBlockDelete::Clear();
  clear_has_tpblockdelete();
}
inline const ::pb::TaskPlanBlockDelete& Container::tpblockdelete() const {
  return tpblockdelete_ != NULL ? *tpblockdelete_ : *default_instance_->tpblockdelete_;
}
inline ::pb::TaskPlanBlockDelete* Container::mutable_tpblockdelete() {
  set_has_tpblockdelete();
  if (tpblockdelete_ == NULL) tpblockdelete_ = new ::pb::TaskPlanBlockDelete;
  return tpblockdelete_;
}
inline ::pb::TaskPlanBlockDelete* Container::release_tpblockdelete() {
  clear_has_tpblockdelete();
  ::pb::TaskPlanBlockDelete* temp = tpblockdelete_;
  tpblockdelete_ = NULL;
  return temp;
}
inline void Container::set_allocated_tpblockdelete(::pb::TaskPlanBlockDelete* tpblockdelete) {
  delete tpblockdelete_;
  tpblockdelete_ = tpblockdelete;
  if (tpblockdelete) {
    set_has_tpblockdelete();
  } else {
    clear_has_tpblockdelete();
  }
}

// optional .pb.TaskPlanOptionalStop tpoptionalstop = 202;
inline bool Container::has_tpoptionalstop() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void Container::set_has_tpoptionalstop() {
  _has_bits_[1] |= 0x40000000u;
}
inline void Container::clear_has_tpoptionalstop() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void Container::clear_tpoptionalstop() {
  if (tpoptionalstop_ != NULL) tpoptionalstop_->::pb::TaskPlanOptionalStop::Clear();
  clear_has_tpoptionalstop();
}
inline const ::pb::TaskPlanOptionalStop& Container::tpoptionalstop() const {
  return tpoptionalstop_ != NULL ? *tpoptionalstop_ : *default_instance_->tpoptionalstop_;
}
inline ::pb::TaskPlanOptionalStop* Container::mutable_tpoptionalstop() {
  set_has_tpoptionalstop();
  if (tpoptionalstop_ == NULL) tpoptionalstop_ = new ::pb::TaskPlanOptionalStop;
  return tpoptionalstop_;
}
inline ::pb::TaskPlanOptionalStop* Container::release_tpoptionalstop() {
  clear_has_tpoptionalstop();
  ::pb::TaskPlanOptionalStop* temp = tpoptionalstop_;
  tpoptionalstop_ = NULL;
  return temp;
}
inline void Container::set_allocated_tpoptionalstop(::pb::TaskPlanOptionalStop* tpoptionalstop) {
  delete tpoptionalstop_;
  tpoptionalstop_ = tpoptionalstop;
  if (tpoptionalstop) {
    set_has_tpoptionalstop();
  } else {
    clear_has_tpoptionalstop();
  }
}

// optional .pb.TaskPlanOpen tpopen = 203;
inline bool Container::has_tpopen() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void Container::set_has_tpopen() {
  _has_bits_[1] |= 0x80000000u;
}
inline void Container::clear_has_tpopen() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void Container::clear_tpopen() {
  if (tpopen_ != NULL) tpopen_->::pb::TaskPlanOpen::Clear();
  clear_has_tpopen();
}
inline const ::pb::TaskPlanOpen& Container::tpopen() const {
  return tpopen_ != NULL ? *tpopen_ : *default_instance_->tpopen_;
}
inline ::pb::TaskPlanOpen* Container::mutable_tpopen() {
  set_has_tpopen();
  if (tpopen_ == NULL) tpopen_ = new ::pb::TaskPlanOpen;
  return tpopen_;
}
inline ::pb::TaskPlanOpen* Container::release_tpopen() {
  clear_has_tpopen();
  ::pb::TaskPlanOpen* temp = tpopen_;
  tpopen_ = NULL;
  return temp;
}
inline void Container::set_allocated_tpopen(::pb::TaskPlanOpen* tpopen) {
  delete tpopen_;
  tpopen_ = tpopen;
  if (tpopen) {
    set_has_tpopen();
  } else {
    clear_has_tpopen();
  }
}

// optional .pb.TaskPlanReply taskplan_reply = 210;
inline bool Container::has_taskplan_reply() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void Container::set_has_taskplan_reply() {
  _has_bits_[2] |= 0x00000001u;
}
inline void Container::clear_has_taskplan_reply() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void Container::clear_taskplan_reply() {
  if (taskplan_reply_ != NULL) taskplan_reply_->::pb::TaskPlanReply::Clear();
  clear_has_taskplan_reply();
}
inline const ::pb::TaskPlanReply& Container::taskplan_reply() const {
  return taskplan_reply_ != NULL ? *taskplan_reply_ : *default_instance_->taskplan_reply_;
}
inline ::pb::TaskPlanReply* Container::mutable_taskplan_reply() {
  set_has_taskplan_reply();
  if (taskplan_reply_ == NULL) taskplan_reply_ = new ::pb::TaskPlanReply;
  return taskplan_reply_;
}
inline ::pb::TaskPlanReply* Container::release_taskplan_reply() {
  clear_has_taskplan_reply();
  ::pb::TaskPlanReply* temp = taskplan_reply_;
  taskplan_reply_ = NULL;
  return temp;
}
inline void Container::set_allocated_taskplan_reply(::pb::TaskPlanReply* taskplan_reply) {
  delete taskplan_reply_;
  taskplan_reply_ = taskplan_reply;
  if (taskplan_reply) {
    set_has_taskplan_reply();
  } else {
    clear_has_taskplan_reply();
  }
}

// optional .pb.Emc_Traj_Set_G5x traj_set_g5x = 300;
inline bool Container::has_traj_set_g5x() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void Container::set_has_traj_set_g5x() {
  _has_bits_[2] |= 0x00000002u;
}
inline void Container::clear_has_traj_set_g5x() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void Container::clear_traj_set_g5x() {
  if (traj_set_g5x_ != NULL) traj_set_g5x_->::pb::Emc_Traj_Set_G5x::Clear();
  clear_has_traj_set_g5x();
}
inline const ::pb::Emc_Traj_Set_G5x& Container::traj_set_g5x() const {
  return traj_set_g5x_ != NULL ? *traj_set_g5x_ : *default_instance_->traj_set_g5x_;
}
inline ::pb::Emc_Traj_Set_G5x* Container::mutable_traj_set_g5x() {
  set_has_traj_set_g5x();
  if (traj_set_g5x_ == NULL) traj_set_g5x_ = new ::pb::Emc_Traj_Set_G5x;
  return traj_set_g5x_;
}
inline ::pb::Emc_Traj_Set_G5x* Container::release_traj_set_g5x() {
  clear_has_traj_set_g5x();
  ::pb::Emc_Traj_Set_G5x* temp = traj_set_g5x_;
  traj_set_g5x_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_g5x(::pb::Emc_Traj_Set_G5x* traj_set_g5x) {
  delete traj_set_g5x_;
  traj_set_g5x_ = traj_set_g5x;
  if (traj_set_g5x) {
    set_has_traj_set_g5x();
  } else {
    clear_has_traj_set_g5x();
  }
}

// optional .pb.Emc_Traj_Set_G92 traj_set_g92 = 310;
inline bool Container::has_traj_set_g92() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void Container::set_has_traj_set_g92() {
  _has_bits_[2] |= 0x00000004u;
}
inline void Container::clear_has_traj_set_g92() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void Container::clear_traj_set_g92() {
  if (traj_set_g92_ != NULL) traj_set_g92_->::pb::Emc_Traj_Set_G92::Clear();
  clear_has_traj_set_g92();
}
inline const ::pb::Emc_Traj_Set_G92& Container::traj_set_g92() const {
  return traj_set_g92_ != NULL ? *traj_set_g92_ : *default_instance_->traj_set_g92_;
}
inline ::pb::Emc_Traj_Set_G92* Container::mutable_traj_set_g92() {
  set_has_traj_set_g92();
  if (traj_set_g92_ == NULL) traj_set_g92_ = new ::pb::Emc_Traj_Set_G92;
  return traj_set_g92_;
}
inline ::pb::Emc_Traj_Set_G92* Container::release_traj_set_g92() {
  clear_has_traj_set_g92();
  ::pb::Emc_Traj_Set_G92* temp = traj_set_g92_;
  traj_set_g92_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_g92(::pb::Emc_Traj_Set_G92* traj_set_g92) {
  delete traj_set_g92_;
  traj_set_g92_ = traj_set_g92;
  if (traj_set_g92) {
    set_has_traj_set_g92();
  } else {
    clear_has_traj_set_g92();
  }
}

// optional .pb.Emc_Traj_Set_Rotation traj_set_rotation = 320;
inline bool Container::has_traj_set_rotation() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void Container::set_has_traj_set_rotation() {
  _has_bits_[2] |= 0x00000008u;
}
inline void Container::clear_has_traj_set_rotation() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void Container::clear_traj_set_rotation() {
  if (traj_set_rotation_ != NULL) traj_set_rotation_->::pb::Emc_Traj_Set_Rotation::Clear();
  clear_has_traj_set_rotation();
}
inline const ::pb::Emc_Traj_Set_Rotation& Container::traj_set_rotation() const {
  return traj_set_rotation_ != NULL ? *traj_set_rotation_ : *default_instance_->traj_set_rotation_;
}
inline ::pb::Emc_Traj_Set_Rotation* Container::mutable_traj_set_rotation() {
  set_has_traj_set_rotation();
  if (traj_set_rotation_ == NULL) traj_set_rotation_ = new ::pb::Emc_Traj_Set_Rotation;
  return traj_set_rotation_;
}
inline ::pb::Emc_Traj_Set_Rotation* Container::release_traj_set_rotation() {
  clear_has_traj_set_rotation();
  ::pb::Emc_Traj_Set_Rotation* temp = traj_set_rotation_;
  traj_set_rotation_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_rotation(::pb::Emc_Traj_Set_Rotation* traj_set_rotation) {
  delete traj_set_rotation_;
  traj_set_rotation_ = traj_set_rotation;
  if (traj_set_rotation) {
    set_has_traj_set_rotation();
  } else {
    clear_has_traj_set_rotation();
  }
}

// optional .pb.Emc_Traj_Linear_Move traj_linear_move = 330;
inline bool Container::has_traj_linear_move() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void Container::set_has_traj_linear_move() {
  _has_bits_[2] |= 0x00000010u;
}
inline void Container::clear_has_traj_linear_move() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void Container::clear_traj_linear_move() {
  if (traj_linear_move_ != NULL) traj_linear_move_->::pb::Emc_Traj_Linear_Move::Clear();
  clear_has_traj_linear_move();
}
inline const ::pb::Emc_Traj_Linear_Move& Container::traj_linear_move() const {
  return traj_linear_move_ != NULL ? *traj_linear_move_ : *default_instance_->traj_linear_move_;
}
inline ::pb::Emc_Traj_Linear_Move* Container::mutable_traj_linear_move() {
  set_has_traj_linear_move();
  if (traj_linear_move_ == NULL) traj_linear_move_ = new ::pb::Emc_Traj_Linear_Move;
  return traj_linear_move_;
}
inline ::pb::Emc_Traj_Linear_Move* Container::release_traj_linear_move() {
  clear_has_traj_linear_move();
  ::pb::Emc_Traj_Linear_Move* temp = traj_linear_move_;
  traj_linear_move_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_linear_move(::pb::Emc_Traj_Linear_Move* traj_linear_move) {
  delete traj_linear_move_;
  traj_linear_move_ = traj_linear_move;
  if (traj_linear_move) {
    set_has_traj_linear_move();
  } else {
    clear_has_traj_linear_move();
  }
}

// optional .pb.Emc_Traj_Probe traj_probe = 340;
inline bool Container::has_traj_probe() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void Container::set_has_traj_probe() {
  _has_bits_[2] |= 0x00000020u;
}
inline void Container::clear_has_traj_probe() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void Container::clear_traj_probe() {
  if (traj_probe_ != NULL) traj_probe_->::pb::Emc_Traj_Probe::Clear();
  clear_has_traj_probe();
}
inline const ::pb::Emc_Traj_Probe& Container::traj_probe() const {
  return traj_probe_ != NULL ? *traj_probe_ : *default_instance_->traj_probe_;
}
inline ::pb::Emc_Traj_Probe* Container::mutable_traj_probe() {
  set_has_traj_probe();
  if (traj_probe_ == NULL) traj_probe_ = new ::pb::Emc_Traj_Probe;
  return traj_probe_;
}
inline ::pb::Emc_Traj_Probe* Container::release_traj_probe() {
  clear_has_traj_probe();
  ::pb::Emc_Traj_Probe* temp = traj_probe_;
  traj_probe_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_probe(::pb::Emc_Traj_Probe* traj_probe) {
  delete traj_probe_;
  traj_probe_ = traj_probe;
  if (traj_probe) {
    set_has_traj_probe();
  } else {
    clear_has_traj_probe();
  }
}

// optional .pb.Emc_Traj_Circular_Move traj_circular_move = 350;
inline bool Container::has_traj_circular_move() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void Container::set_has_traj_circular_move() {
  _has_bits_[2] |= 0x00000040u;
}
inline void Container::clear_has_traj_circular_move() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void Container::clear_traj_circular_move() {
  if (traj_circular_move_ != NULL) traj_circular_move_->::pb::Emc_Traj_Circular_Move::Clear();
  clear_has_traj_circular_move();
}
inline const ::pb::Emc_Traj_Circular_Move& Container::traj_circular_move() const {
  return traj_circular_move_ != NULL ? *traj_circular_move_ : *default_instance_->traj_circular_move_;
}
inline ::pb::Emc_Traj_Circular_Move* Container::mutable_traj_circular_move() {
  set_has_traj_circular_move();
  if (traj_circular_move_ == NULL) traj_circular_move_ = new ::pb::Emc_Traj_Circular_Move;
  return traj_circular_move_;
}
inline ::pb::Emc_Traj_Circular_Move* Container::release_traj_circular_move() {
  clear_has_traj_circular_move();
  ::pb::Emc_Traj_Circular_Move* temp = traj_circular_move_;
  traj_circular_move_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_circular_move(::pb::Emc_Traj_Circular_Move* traj_circular_move) {
  delete traj_circular_move_;
  traj_circular_move_ = traj_circular_move;
  if (traj_circular_move) {
    set_has_traj_circular_move();
  } else {
    clear_has_traj_circular_move();
  }
}

// optional .pb.Emc_Traj_Rigid_Tap traj_rigid_tap = 360;
inline bool Container::has_traj_rigid_tap() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void Container::set_has_traj_rigid_tap() {
  _has_bits_[2] |= 0x00000080u;
}
inline void Container::clear_has_traj_rigid_tap() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void Container::clear_traj_rigid_tap() {
  if (traj_rigid_tap_ != NULL) traj_rigid_tap_->::pb::Emc_Traj_Rigid_Tap::Clear();
  clear_has_traj_rigid_tap();
}
inline const ::pb::Emc_Traj_Rigid_Tap& Container::traj_rigid_tap() const {
  return traj_rigid_tap_ != NULL ? *traj_rigid_tap_ : *default_instance_->traj_rigid_tap_;
}
inline ::pb::Emc_Traj_Rigid_Tap* Container::mutable_traj_rigid_tap() {
  set_has_traj_rigid_tap();
  if (traj_rigid_tap_ == NULL) traj_rigid_tap_ = new ::pb::Emc_Traj_Rigid_Tap;
  return traj_rigid_tap_;
}
inline ::pb::Emc_Traj_Rigid_Tap* Container::release_traj_rigid_tap() {
  clear_has_traj_rigid_tap();
  ::pb::Emc_Traj_Rigid_Tap* temp = traj_rigid_tap_;
  traj_rigid_tap_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_rigid_tap(::pb::Emc_Traj_Rigid_Tap* traj_rigid_tap) {
  delete traj_rigid_tap_;
  traj_rigid_tap_ = traj_rigid_tap;
  if (traj_rigid_tap) {
    set_has_traj_rigid_tap();
  } else {
    clear_has_traj_rigid_tap();
  }
}

// optional .pb.Emc_Traj_Set_Term_Cond traj_set_term_cond = 370;
inline bool Container::has_traj_set_term_cond() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void Container::set_has_traj_set_term_cond() {
  _has_bits_[2] |= 0x00000100u;
}
inline void Container::clear_has_traj_set_term_cond() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void Container::clear_traj_set_term_cond() {
  if (traj_set_term_cond_ != NULL) traj_set_term_cond_->::pb::Emc_Traj_Set_Term_Cond::Clear();
  clear_has_traj_set_term_cond();
}
inline const ::pb::Emc_Traj_Set_Term_Cond& Container::traj_set_term_cond() const {
  return traj_set_term_cond_ != NULL ? *traj_set_term_cond_ : *default_instance_->traj_set_term_cond_;
}
inline ::pb::Emc_Traj_Set_Term_Cond* Container::mutable_traj_set_term_cond() {
  set_has_traj_set_term_cond();
  if (traj_set_term_cond_ == NULL) traj_set_term_cond_ = new ::pb::Emc_Traj_Set_Term_Cond;
  return traj_set_term_cond_;
}
inline ::pb::Emc_Traj_Set_Term_Cond* Container::release_traj_set_term_cond() {
  clear_has_traj_set_term_cond();
  ::pb::Emc_Traj_Set_Term_Cond* temp = traj_set_term_cond_;
  traj_set_term_cond_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_term_cond(::pb::Emc_Traj_Set_Term_Cond* traj_set_term_cond) {
  delete traj_set_term_cond_;
  traj_set_term_cond_ = traj_set_term_cond;
  if (traj_set_term_cond) {
    set_has_traj_set_term_cond();
  } else {
    clear_has_traj_set_term_cond();
  }
}

// optional .pb.Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
inline bool Container::has_traj_set_spindlesync() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void Container::set_has_traj_set_spindlesync() {
  _has_bits_[2] |= 0x00000200u;
}
inline void Container::clear_has_traj_set_spindlesync() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void Container::clear_traj_set_spindlesync() {
  if (traj_set_spindlesync_ != NULL) traj_set_spindlesync_->::pb::Emc_Traj_Set_Spindlesync::Clear();
  clear_has_traj_set_spindlesync();
}
inline const ::pb::Emc_Traj_Set_Spindlesync& Container::traj_set_spindlesync() const {
  return traj_set_spindlesync_ != NULL ? *traj_set_spindlesync_ : *default_instance_->traj_set_spindlesync_;
}
inline ::pb::Emc_Traj_Set_Spindlesync* Container::mutable_traj_set_spindlesync() {
  set_has_traj_set_spindlesync();
  if (traj_set_spindlesync_ == NULL) traj_set_spindlesync_ = new ::pb::Emc_Traj_Set_Spindlesync;
  return traj_set_spindlesync_;
}
inline ::pb::Emc_Traj_Set_Spindlesync* Container::release_traj_set_spindlesync() {
  clear_has_traj_set_spindlesync();
  ::pb::Emc_Traj_Set_Spindlesync* temp = traj_set_spindlesync_;
  traj_set_spindlesync_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_spindlesync(::pb::Emc_Traj_Set_Spindlesync* traj_set_spindlesync) {
  delete traj_set_spindlesync_;
  traj_set_spindlesync_ = traj_set_spindlesync;
  if (traj_set_spindlesync) {
    set_has_traj_set_spindlesync();
  } else {
    clear_has_traj_set_spindlesync();
  }
}

// optional .pb.Emc_Traj_Delay traj_delay = 390;
inline bool Container::has_traj_delay() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void Container::set_has_traj_delay() {
  _has_bits_[2] |= 0x00000400u;
}
inline void Container::clear_has_traj_delay() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void Container::clear_traj_delay() {
  if (traj_delay_ != NULL) traj_delay_->::pb::Emc_Traj_Delay::Clear();
  clear_has_traj_delay();
}
inline const ::pb::Emc_Traj_Delay& Container::traj_delay() const {
  return traj_delay_ != NULL ? *traj_delay_ : *default_instance_->traj_delay_;
}
inline ::pb::Emc_Traj_Delay* Container::mutable_traj_delay() {
  set_has_traj_delay();
  if (traj_delay_ == NULL) traj_delay_ = new ::pb::Emc_Traj_Delay;
  return traj_delay_;
}
inline ::pb::Emc_Traj_Delay* Container::release_traj_delay() {
  clear_has_traj_delay();
  ::pb::Emc_Traj_Delay* temp = traj_delay_;
  traj_delay_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_delay(::pb::Emc_Traj_Delay* traj_delay) {
  delete traj_delay_;
  traj_delay_ = traj_delay;
  if (traj_delay) {
    set_has_traj_delay();
  } else {
    clear_has_traj_delay();
  }
}

// optional .pb.Emc_Spindle_On spindle_on = 400;
inline bool Container::has_spindle_on() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void Container::set_has_spindle_on() {
  _has_bits_[2] |= 0x00000800u;
}
inline void Container::clear_has_spindle_on() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void Container::clear_spindle_on() {
  if (spindle_on_ != NULL) spindle_on_->::pb::Emc_Spindle_On::Clear();
  clear_has_spindle_on();
}
inline const ::pb::Emc_Spindle_On& Container::spindle_on() const {
  return spindle_on_ != NULL ? *spindle_on_ : *default_instance_->spindle_on_;
}
inline ::pb::Emc_Spindle_On* Container::mutable_spindle_on() {
  set_has_spindle_on();
  if (spindle_on_ == NULL) spindle_on_ = new ::pb::Emc_Spindle_On;
  return spindle_on_;
}
inline ::pb::Emc_Spindle_On* Container::release_spindle_on() {
  clear_has_spindle_on();
  ::pb::Emc_Spindle_On* temp = spindle_on_;
  spindle_on_ = NULL;
  return temp;
}
inline void Container::set_allocated_spindle_on(::pb::Emc_Spindle_On* spindle_on) {
  delete spindle_on_;
  spindle_on_ = spindle_on;
  if (spindle_on) {
    set_has_spindle_on();
  } else {
    clear_has_spindle_on();
  }
}

// optional .pb.Emc_Spindle_Speed spindle_speed = 410;
inline bool Container::has_spindle_speed() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void Container::set_has_spindle_speed() {
  _has_bits_[2] |= 0x00001000u;
}
inline void Container::clear_has_spindle_speed() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void Container::clear_spindle_speed() {
  if (spindle_speed_ != NULL) spindle_speed_->::pb::Emc_Spindle_Speed::Clear();
  clear_has_spindle_speed();
}
inline const ::pb::Emc_Spindle_Speed& Container::spindle_speed() const {
  return spindle_speed_ != NULL ? *spindle_speed_ : *default_instance_->spindle_speed_;
}
inline ::pb::Emc_Spindle_Speed* Container::mutable_spindle_speed() {
  set_has_spindle_speed();
  if (spindle_speed_ == NULL) spindle_speed_ = new ::pb::Emc_Spindle_Speed;
  return spindle_speed_;
}
inline ::pb::Emc_Spindle_Speed* Container::release_spindle_speed() {
  clear_has_spindle_speed();
  ::pb::Emc_Spindle_Speed* temp = spindle_speed_;
  spindle_speed_ = NULL;
  return temp;
}
inline void Container::set_allocated_spindle_speed(::pb::Emc_Spindle_Speed* spindle_speed) {
  delete spindle_speed_;
  spindle_speed_ = spindle_speed;
  if (spindle_speed) {
    set_has_spindle_speed();
  } else {
    clear_has_spindle_speed();
  }
}

// optional .pb.Emc_Spindle_Orient spindle_orient = 420;
inline bool Container::has_spindle_orient() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void Container::set_has_spindle_orient() {
  _has_bits_[2] |= 0x00002000u;
}
inline void Container::clear_has_spindle_orient() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void Container::clear_spindle_orient() {
  if (spindle_orient_ != NULL) spindle_orient_->::pb::Emc_Spindle_Orient::Clear();
  clear_has_spindle_orient();
}
inline const ::pb::Emc_Spindle_Orient& Container::spindle_orient() const {
  return spindle_orient_ != NULL ? *spindle_orient_ : *default_instance_->spindle_orient_;
}
inline ::pb::Emc_Spindle_Orient* Container::mutable_spindle_orient() {
  set_has_spindle_orient();
  if (spindle_orient_ == NULL) spindle_orient_ = new ::pb::Emc_Spindle_Orient;
  return spindle_orient_;
}
inline ::pb::Emc_Spindle_Orient* Container::release_spindle_orient() {
  clear_has_spindle_orient();
  ::pb::Emc_Spindle_Orient* temp = spindle_orient_;
  spindle_orient_ = NULL;
  return temp;
}
inline void Container::set_allocated_spindle_orient(::pb::Emc_Spindle_Orient* spindle_orient) {
  delete spindle_orient_;
  spindle_orient_ = spindle_orient;
  if (spindle_orient) {
    set_has_spindle_orient();
  } else {
    clear_has_spindle_orient();
  }
}

// optional .pb.Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
inline bool Container::has_spindle_wait_orient_complete() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void Container::set_has_spindle_wait_orient_complete() {
  _has_bits_[2] |= 0x00004000u;
}
inline void Container::clear_has_spindle_wait_orient_complete() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void Container::clear_spindle_wait_orient_complete() {
  if (spindle_wait_orient_complete_ != NULL) spindle_wait_orient_complete_->::pb::Emc_Spindle_Wait_Orient_Complete::Clear();
  clear_has_spindle_wait_orient_complete();
}
inline const ::pb::Emc_Spindle_Wait_Orient_Complete& Container::spindle_wait_orient_complete() const {
  return spindle_wait_orient_complete_ != NULL ? *spindle_wait_orient_complete_ : *default_instance_->spindle_wait_orient_complete_;
}
inline ::pb::Emc_Spindle_Wait_Orient_Complete* Container::mutable_spindle_wait_orient_complete() {
  set_has_spindle_wait_orient_complete();
  if (spindle_wait_orient_complete_ == NULL) spindle_wait_orient_complete_ = new ::pb::Emc_Spindle_Wait_Orient_Complete;
  return spindle_wait_orient_complete_;
}
inline ::pb::Emc_Spindle_Wait_Orient_Complete* Container::release_spindle_wait_orient_complete() {
  clear_has_spindle_wait_orient_complete();
  ::pb::Emc_Spindle_Wait_Orient_Complete* temp = spindle_wait_orient_complete_;
  spindle_wait_orient_complete_ = NULL;
  return temp;
}
inline void Container::set_allocated_spindle_wait_orient_complete(::pb::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete) {
  delete spindle_wait_orient_complete_;
  spindle_wait_orient_complete_ = spindle_wait_orient_complete;
  if (spindle_wait_orient_complete) {
    set_has_spindle_wait_orient_complete();
  } else {
    clear_has_spindle_wait_orient_complete();
  }
}

// optional .pb.Emc_Tool_Set_Offset tool_set_offet = 440;
inline bool Container::has_tool_set_offet() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void Container::set_has_tool_set_offet() {
  _has_bits_[2] |= 0x00008000u;
}
inline void Container::clear_has_tool_set_offet() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void Container::clear_tool_set_offet() {
  if (tool_set_offet_ != NULL) tool_set_offet_->::pb::Emc_Tool_Set_Offset::Clear();
  clear_has_tool_set_offet();
}
inline const ::pb::Emc_Tool_Set_Offset& Container::tool_set_offet() const {
  return tool_set_offet_ != NULL ? *tool_set_offet_ : *default_instance_->tool_set_offet_;
}
inline ::pb::Emc_Tool_Set_Offset* Container::mutable_tool_set_offet() {
  set_has_tool_set_offet();
  if (tool_set_offet_ == NULL) tool_set_offet_ = new ::pb::Emc_Tool_Set_Offset;
  return tool_set_offet_;
}
inline ::pb::Emc_Tool_Set_Offset* Container::release_tool_set_offet() {
  clear_has_tool_set_offet();
  ::pb::Emc_Tool_Set_Offset* temp = tool_set_offet_;
  tool_set_offet_ = NULL;
  return temp;
}
inline void Container::set_allocated_tool_set_offet(::pb::Emc_Tool_Set_Offset* tool_set_offet) {
  delete tool_set_offet_;
  tool_set_offet_ = tool_set_offet;
  if (tool_set_offet) {
    set_has_tool_set_offet();
  } else {
    clear_has_tool_set_offet();
  }
}

// optional .pb.Emc_Traj_Set_Offset traj_set_offset = 450;
inline bool Container::has_traj_set_offset() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void Container::set_has_traj_set_offset() {
  _has_bits_[2] |= 0x00010000u;
}
inline void Container::clear_has_traj_set_offset() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void Container::clear_traj_set_offset() {
  if (traj_set_offset_ != NULL) traj_set_offset_->::pb::Emc_Traj_Set_Offset::Clear();
  clear_has_traj_set_offset();
}
inline const ::pb::Emc_Traj_Set_Offset& Container::traj_set_offset() const {
  return traj_set_offset_ != NULL ? *traj_set_offset_ : *default_instance_->traj_set_offset_;
}
inline ::pb::Emc_Traj_Set_Offset* Container::mutable_traj_set_offset() {
  set_has_traj_set_offset();
  if (traj_set_offset_ == NULL) traj_set_offset_ = new ::pb::Emc_Traj_Set_Offset;
  return traj_set_offset_;
}
inline ::pb::Emc_Traj_Set_Offset* Container::release_traj_set_offset() {
  clear_has_traj_set_offset();
  ::pb::Emc_Traj_Set_Offset* temp = traj_set_offset_;
  traj_set_offset_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_offset(::pb::Emc_Traj_Set_Offset* traj_set_offset) {
  delete traj_set_offset_;
  traj_set_offset_ = traj_set_offset;
  if (traj_set_offset) {
    set_has_traj_set_offset();
  } else {
    clear_has_traj_set_offset();
  }
}

// optional .pb.Emc_Tool_Prepare tool_prepare = 460;
inline bool Container::has_tool_prepare() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void Container::set_has_tool_prepare() {
  _has_bits_[2] |= 0x00020000u;
}
inline void Container::clear_has_tool_prepare() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void Container::clear_tool_prepare() {
  if (tool_prepare_ != NULL) tool_prepare_->::pb::Emc_Tool_Prepare::Clear();
  clear_has_tool_prepare();
}
inline const ::pb::Emc_Tool_Prepare& Container::tool_prepare() const {
  return tool_prepare_ != NULL ? *tool_prepare_ : *default_instance_->tool_prepare_;
}
inline ::pb::Emc_Tool_Prepare* Container::mutable_tool_prepare() {
  set_has_tool_prepare();
  if (tool_prepare_ == NULL) tool_prepare_ = new ::pb::Emc_Tool_Prepare;
  return tool_prepare_;
}
inline ::pb::Emc_Tool_Prepare* Container::release_tool_prepare() {
  clear_has_tool_prepare();
  ::pb::Emc_Tool_Prepare* temp = tool_prepare_;
  tool_prepare_ = NULL;
  return temp;
}
inline void Container::set_allocated_tool_prepare(::pb::Emc_Tool_Prepare* tool_prepare) {
  delete tool_prepare_;
  tool_prepare_ = tool_prepare;
  if (tool_prepare) {
    set_has_tool_prepare();
  } else {
    clear_has_tool_prepare();
  }
}

// optional .pb.Emc_Tool_Set_Number tool_set_number = 470;
inline bool Container::has_tool_set_number() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void Container::set_has_tool_set_number() {
  _has_bits_[2] |= 0x00040000u;
}
inline void Container::clear_has_tool_set_number() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void Container::clear_tool_set_number() {
  if (tool_set_number_ != NULL) tool_set_number_->::pb::Emc_Tool_Set_Number::Clear();
  clear_has_tool_set_number();
}
inline const ::pb::Emc_Tool_Set_Number& Container::tool_set_number() const {
  return tool_set_number_ != NULL ? *tool_set_number_ : *default_instance_->tool_set_number_;
}
inline ::pb::Emc_Tool_Set_Number* Container::mutable_tool_set_number() {
  set_has_tool_set_number();
  if (tool_set_number_ == NULL) tool_set_number_ = new ::pb::Emc_Tool_Set_Number;
  return tool_set_number_;
}
inline ::pb::Emc_Tool_Set_Number* Container::release_tool_set_number() {
  clear_has_tool_set_number();
  ::pb::Emc_Tool_Set_Number* temp = tool_set_number_;
  tool_set_number_ = NULL;
  return temp;
}
inline void Container::set_allocated_tool_set_number(::pb::Emc_Tool_Set_Number* tool_set_number) {
  delete tool_set_number_;
  tool_set_number_ = tool_set_number;
  if (tool_set_number) {
    set_has_tool_set_number();
  } else {
    clear_has_tool_set_number();
  }
}

// optional .pb.Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
inline bool Container::has_traj_set_fo_enable() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void Container::set_has_traj_set_fo_enable() {
  _has_bits_[2] |= 0x00080000u;
}
inline void Container::clear_has_traj_set_fo_enable() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void Container::clear_traj_set_fo_enable() {
  if (traj_set_fo_enable_ != NULL) traj_set_fo_enable_->::pb::Emc_Traj_Set_Fo_Enable::Clear();
  clear_has_traj_set_fo_enable();
}
inline const ::pb::Emc_Traj_Set_Fo_Enable& Container::traj_set_fo_enable() const {
  return traj_set_fo_enable_ != NULL ? *traj_set_fo_enable_ : *default_instance_->traj_set_fo_enable_;
}
inline ::pb::Emc_Traj_Set_Fo_Enable* Container::mutable_traj_set_fo_enable() {
  set_has_traj_set_fo_enable();
  if (traj_set_fo_enable_ == NULL) traj_set_fo_enable_ = new ::pb::Emc_Traj_Set_Fo_Enable;
  return traj_set_fo_enable_;
}
inline ::pb::Emc_Traj_Set_Fo_Enable* Container::release_traj_set_fo_enable() {
  clear_has_traj_set_fo_enable();
  ::pb::Emc_Traj_Set_Fo_Enable* temp = traj_set_fo_enable_;
  traj_set_fo_enable_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_fo_enable(::pb::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable) {
  delete traj_set_fo_enable_;
  traj_set_fo_enable_ = traj_set_fo_enable;
  if (traj_set_fo_enable) {
    set_has_traj_set_fo_enable();
  } else {
    clear_has_traj_set_fo_enable();
  }
}

// optional .pb.Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
inline bool Container::has_traj_set_so_enable() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void Container::set_has_traj_set_so_enable() {
  _has_bits_[2] |= 0x00100000u;
}
inline void Container::clear_has_traj_set_so_enable() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void Container::clear_traj_set_so_enable() {
  if (traj_set_so_enable_ != NULL) traj_set_so_enable_->::pb::Emc_Traj_Set_So_Enable::Clear();
  clear_has_traj_set_so_enable();
}
inline const ::pb::Emc_Traj_Set_So_Enable& Container::traj_set_so_enable() const {
  return traj_set_so_enable_ != NULL ? *traj_set_so_enable_ : *default_instance_->traj_set_so_enable_;
}
inline ::pb::Emc_Traj_Set_So_Enable* Container::mutable_traj_set_so_enable() {
  set_has_traj_set_so_enable();
  if (traj_set_so_enable_ == NULL) traj_set_so_enable_ = new ::pb::Emc_Traj_Set_So_Enable;
  return traj_set_so_enable_;
}
inline ::pb::Emc_Traj_Set_So_Enable* Container::release_traj_set_so_enable() {
  clear_has_traj_set_so_enable();
  ::pb::Emc_Traj_Set_So_Enable* temp = traj_set_so_enable_;
  traj_set_so_enable_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_so_enable(::pb::Emc_Traj_Set_So_Enable* traj_set_so_enable) {
  delete traj_set_so_enable_;
  traj_set_so_enable_ = traj_set_so_enable;
  if (traj_set_so_enable) {
    set_has_traj_set_so_enable();
  } else {
    clear_has_traj_set_so_enable();
  }
}

// optional .pb.Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
inline bool Container::has_traj_set_fh_enable() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void Container::set_has_traj_set_fh_enable() {
  _has_bits_[2] |= 0x00200000u;
}
inline void Container::clear_has_traj_set_fh_enable() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void Container::clear_traj_set_fh_enable() {
  if (traj_set_fh_enable_ != NULL) traj_set_fh_enable_->::pb::Emc_Traj_Set_Fh_Enable::Clear();
  clear_has_traj_set_fh_enable();
}
inline const ::pb::Emc_Traj_Set_Fh_Enable& Container::traj_set_fh_enable() const {
  return traj_set_fh_enable_ != NULL ? *traj_set_fh_enable_ : *default_instance_->traj_set_fh_enable_;
}
inline ::pb::Emc_Traj_Set_Fh_Enable* Container::mutable_traj_set_fh_enable() {
  set_has_traj_set_fh_enable();
  if (traj_set_fh_enable_ == NULL) traj_set_fh_enable_ = new ::pb::Emc_Traj_Set_Fh_Enable;
  return traj_set_fh_enable_;
}
inline ::pb::Emc_Traj_Set_Fh_Enable* Container::release_traj_set_fh_enable() {
  clear_has_traj_set_fh_enable();
  ::pb::Emc_Traj_Set_Fh_Enable* temp = traj_set_fh_enable_;
  traj_set_fh_enable_ = NULL;
  return temp;
}
inline void Container::set_allocated_traj_set_fh_enable(::pb::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable) {
  delete traj_set_fh_enable_;
  traj_set_fh_enable_ = traj_set_fh_enable;
  if (traj_set_fh_enable) {
    set_has_traj_set_fh_enable();
  } else {
    clear_has_traj_set_fh_enable();
  }
}

// optional .pb.Emc_Motion_Adaptive motion_adaptive = 510;
inline bool Container::has_motion_adaptive() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void Container::set_has_motion_adaptive() {
  _has_bits_[2] |= 0x00400000u;
}
inline void Container::clear_has_motion_adaptive() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void Container::clear_motion_adaptive() {
  if (motion_adaptive_ != NULL) motion_adaptive_->::pb::Emc_Motion_Adaptive::Clear();
  clear_has_motion_adaptive();
}
inline const ::pb::Emc_Motion_Adaptive& Container::motion_adaptive() const {
  return motion_adaptive_ != NULL ? *motion_adaptive_ : *default_instance_->motion_adaptive_;
}
inline ::pb::Emc_Motion_Adaptive* Container::mutable_motion_adaptive() {
  set_has_motion_adaptive();
  if (motion_adaptive_ == NULL) motion_adaptive_ = new ::pb::Emc_Motion_Adaptive;
  return motion_adaptive_;
}
inline ::pb::Emc_Motion_Adaptive* Container::release_motion_adaptive() {
  clear_has_motion_adaptive();
  ::pb::Emc_Motion_Adaptive* temp = motion_adaptive_;
  motion_adaptive_ = NULL;
  return temp;
}
inline void Container::set_allocated_motion_adaptive(::pb::Emc_Motion_Adaptive* motion_adaptive) {
  delete motion_adaptive_;
  motion_adaptive_ = motion_adaptive;
  if (motion_adaptive) {
    set_has_motion_adaptive();
  } else {
    clear_has_motion_adaptive();
  }
}

// optional .pb.Emc_Operator_Display operator_display = 520;
inline bool Container::has_operator_display() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void Container::set_has_operator_display() {
  _has_bits_[2] |= 0x00800000u;
}
inline void Container::clear_has_operator_display() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void Container::clear_operator_display() {
  if (operator_display_ != NULL) operator_display_->::pb::Emc_Operator_Display::Clear();
  clear_has_operator_display();
}
inline const ::pb::Emc_Operator_Display& Container::operator_display() const {
  return operator_display_ != NULL ? *operator_display_ : *default_instance_->operator_display_;
}
inline ::pb::Emc_Operator_Display* Container::mutable_operator_display() {
  set_has_operator_display();
  if (operator_display_ == NULL) operator_display_ = new ::pb::Emc_Operator_Display;
  return operator_display_;
}
inline ::pb::Emc_Operator_Display* Container::release_operator_display() {
  clear_has_operator_display();
  ::pb::Emc_Operator_Display* temp = operator_display_;
  operator_display_ = NULL;
  return temp;
}
inline void Container::set_allocated_operator_display(::pb::Emc_Operator_Display* operator_display) {
  delete operator_display_;
  operator_display_ = operator_display;
  if (operator_display) {
    set_has_operator_display();
  } else {
    clear_has_operator_display();
  }
}

// optional .pb.Emc_Operator_Text operator_text = 530;
inline bool Container::has_operator_text() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void Container::set_has_operator_text() {
  _has_bits_[2] |= 0x01000000u;
}
inline void Container::clear_has_operator_text() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void Container::clear_operator_text() {
  if (operator_text_ != NULL) operator_text_->::pb::Emc_Operator_Text::Clear();
  clear_has_operator_text();
}
inline const ::pb::Emc_Operator_Text& Container::operator_text() const {
  return operator_text_ != NULL ? *operator_text_ : *default_instance_->operator_text_;
}
inline ::pb::Emc_Operator_Text* Container::mutable_operator_text() {
  set_has_operator_text();
  if (operator_text_ == NULL) operator_text_ = new ::pb::Emc_Operator_Text;
  return operator_text_;
}
inline ::pb::Emc_Operator_Text* Container::release_operator_text() {
  clear_has_operator_text();
  ::pb::Emc_Operator_Text* temp = operator_text_;
  operator_text_ = NULL;
  return temp;
}
inline void Container::set_allocated_operator_text(::pb::Emc_Operator_Text* operator_text) {
  delete operator_text_;
  operator_text_ = operator_text;
  if (operator_text) {
    set_has_operator_text();
  } else {
    clear_has_operator_text();
  }
}

// optional .pb.Emc_Operator_Error operator_error = 540;
inline bool Container::has_operator_error() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void Container::set_has_operator_error() {
  _has_bits_[2] |= 0x02000000u;
}
inline void Container::clear_has_operator_error() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void Container::clear_operator_error() {
  if (operator_error_ != NULL) operator_error_->::pb::Emc_Operator_Error::Clear();
  clear_has_operator_error();
}
inline const ::pb::Emc_Operator_Error& Container::operator_error() const {
  return operator_error_ != NULL ? *operator_error_ : *default_instance_->operator_error_;
}
inline ::pb::Emc_Operator_Error* Container::mutable_operator_error() {
  set_has_operator_error();
  if (operator_error_ == NULL) operator_error_ = new ::pb::Emc_Operator_Error;
  return operator_error_;
}
inline ::pb::Emc_Operator_Error* Container::release_operator_error() {
  clear_has_operator_error();
  ::pb::Emc_Operator_Error* temp = operator_error_;
  operator_error_ = NULL;
  return temp;
}
inline void Container::set_allocated_operator_error(::pb::Emc_Operator_Error* operator_error) {
  delete operator_error_;
  operator_error_ = operator_error;
  if (operator_error) {
    set_has_operator_error();
  } else {
    clear_has_operator_error();
  }
}

// optional .pb.Emc_Motion_Set_Dout motion_set_dout = 550;
inline bool Container::has_motion_set_dout() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void Container::set_has_motion_set_dout() {
  _has_bits_[2] |= 0x04000000u;
}
inline void Container::clear_has_motion_set_dout() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void Container::clear_motion_set_dout() {
  if (motion_set_dout_ != NULL) motion_set_dout_->::pb::Emc_Motion_Set_Dout::Clear();
  clear_has_motion_set_dout();
}
inline const ::pb::Emc_Motion_Set_Dout& Container::motion_set_dout() const {
  return motion_set_dout_ != NULL ? *motion_set_dout_ : *default_instance_->motion_set_dout_;
}
inline ::pb::Emc_Motion_Set_Dout* Container::mutable_motion_set_dout() {
  set_has_motion_set_dout();
  if (motion_set_dout_ == NULL) motion_set_dout_ = new ::pb::Emc_Motion_Set_Dout;
  return motion_set_dout_;
}
inline ::pb::Emc_Motion_Set_Dout* Container::release_motion_set_dout() {
  clear_has_motion_set_dout();
  ::pb::Emc_Motion_Set_Dout* temp = motion_set_dout_;
  motion_set_dout_ = NULL;
  return temp;
}
inline void Container::set_allocated_motion_set_dout(::pb::Emc_Motion_Set_Dout* motion_set_dout) {
  delete motion_set_dout_;
  motion_set_dout_ = motion_set_dout;
  if (motion_set_dout) {
    set_has_motion_set_dout();
  } else {
    clear_has_motion_set_dout();
  }
}

// optional .pb.Emc_Motion_Set_Aout motion_set_aout = 560;
inline bool Container::has_motion_set_aout() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void Container::set_has_motion_set_aout() {
  _has_bits_[2] |= 0x08000000u;
}
inline void Container::clear_has_motion_set_aout() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void Container::clear_motion_set_aout() {
  if (motion_set_aout_ != NULL) motion_set_aout_->::pb::Emc_Motion_Set_Aout::Clear();
  clear_has_motion_set_aout();
}
inline const ::pb::Emc_Motion_Set_Aout& Container::motion_set_aout() const {
  return motion_set_aout_ != NULL ? *motion_set_aout_ : *default_instance_->motion_set_aout_;
}
inline ::pb::Emc_Motion_Set_Aout* Container::mutable_motion_set_aout() {
  set_has_motion_set_aout();
  if (motion_set_aout_ == NULL) motion_set_aout_ = new ::pb::Emc_Motion_Set_Aout;
  return motion_set_aout_;
}
inline ::pb::Emc_Motion_Set_Aout* Container::release_motion_set_aout() {
  clear_has_motion_set_aout();
  ::pb::Emc_Motion_Set_Aout* temp = motion_set_aout_;
  motion_set_aout_ = NULL;
  return temp;
}
inline void Container::set_allocated_motion_set_aout(::pb::Emc_Motion_Set_Aout* motion_set_aout) {
  delete motion_set_aout_;
  motion_set_aout_ = motion_set_aout;
  if (motion_set_aout) {
    set_has_motion_set_aout();
  } else {
    clear_has_motion_set_aout();
  }
}

// optional .pb.Emc_Aux_Input_Wait aux_input_wait = 570;
inline bool Container::has_aux_input_wait() const {
  return (_has_bits_[2] & 0x10000000u) != 0;
}
inline void Container::set_has_aux_input_wait() {
  _has_bits_[2] |= 0x10000000u;
}
inline void Container::clear_has_aux_input_wait() {
  _has_bits_[2] &= ~0x10000000u;
}
inline void Container::clear_aux_input_wait() {
  if (aux_input_wait_ != NULL) aux_input_wait_->::pb::Emc_Aux_Input_Wait::Clear();
  clear_has_aux_input_wait();
}
inline const ::pb::Emc_Aux_Input_Wait& Container::aux_input_wait() const {
  return aux_input_wait_ != NULL ? *aux_input_wait_ : *default_instance_->aux_input_wait_;
}
inline ::pb::Emc_Aux_Input_Wait* Container::mutable_aux_input_wait() {
  set_has_aux_input_wait();
  if (aux_input_wait_ == NULL) aux_input_wait_ = new ::pb::Emc_Aux_Input_Wait;
  return aux_input_wait_;
}
inline ::pb::Emc_Aux_Input_Wait* Container::release_aux_input_wait() {
  clear_has_aux_input_wait();
  ::pb::Emc_Aux_Input_Wait* temp = aux_input_wait_;
  aux_input_wait_ = NULL;
  return temp;
}
inline void Container::set_allocated_aux_input_wait(::pb::Emc_Aux_Input_Wait* aux_input_wait) {
  delete aux_input_wait_;
  aux_input_wait_ = aux_input_wait;
  if (aux_input_wait) {
    set_has_aux_input_wait();
  } else {
    clear_has_aux_input_wait();
  }
}

// optional .pb.Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
inline bool Container::has_exec_plugin_call() const {
  return (_has_bits_[2] & 0x20000000u) != 0;
}
inline void Container::set_has_exec_plugin_call() {
  _has_bits_[2] |= 0x20000000u;
}
inline void Container::clear_has_exec_plugin_call() {
  _has_bits_[2] &= ~0x20000000u;
}
inline void Container::clear_exec_plugin_call() {
  if (exec_plugin_call_ != NULL) exec_plugin_call_->::pb::Emc_Exec_Plugin_Ca1l::Clear();
  clear_has_exec_plugin_call();
}
inline const ::pb::Emc_Exec_Plugin_Ca1l& Container::exec_plugin_call() const {
  return exec_plugin_call_ != NULL ? *exec_plugin_call_ : *default_instance_->exec_plugin_call_;
}
inline ::pb::Emc_Exec_Plugin_Ca1l* Container::mutable_exec_plugin_call() {
  set_has_exec_plugin_call();
  if (exec_plugin_call_ == NULL) exec_plugin_call_ = new ::pb::Emc_Exec_Plugin_Ca1l;
  return exec_plugin_call_;
}
inline ::pb::Emc_Exec_Plugin_Ca1l* Container::release_exec_plugin_call() {
  clear_has_exec_plugin_call();
  ::pb::Emc_Exec_Plugin_Ca1l* temp = exec_plugin_call_;
  exec_plugin_call_ = NULL;
  return temp;
}
inline void Container::set_allocated_exec_plugin_call(::pb::Emc_Exec_Plugin_Ca1l* exec_plugin_call) {
  delete exec_plugin_call_;
  exec_plugin_call_ = exec_plugin_call;
  if (exec_plugin_call) {
    set_has_exec_plugin_call();
  } else {
    clear_has_exec_plugin_call();
  }
}

// optional .pb.Emc_Io_Plugin_Call io_plugin_call = 590;
inline bool Container::has_io_plugin_call() const {
  return (_has_bits_[2] & 0x40000000u) != 0;
}
inline void Container::set_has_io_plugin_call() {
  _has_bits_[2] |= 0x40000000u;
}
inline void Container::clear_has_io_plugin_call() {
  _has_bits_[2] &= ~0x40000000u;
}
inline void Container::clear_io_plugin_call() {
  if (io_plugin_call_ != NULL) io_plugin_call_->::pb::Emc_Io_Plugin_Call::Clear();
  clear_has_io_plugin_call();
}
inline const ::pb::Emc_Io_Plugin_Call& Container::io_plugin_call() const {
  return io_plugin_call_ != NULL ? *io_plugin_call_ : *default_instance_->io_plugin_call_;
}
inline ::pb::Emc_Io_Plugin_Call* Container::mutable_io_plugin_call() {
  set_has_io_plugin_call();
  if (io_plugin_call_ == NULL) io_plugin_call_ = new ::pb::Emc_Io_Plugin_Call;
  return io_plugin_call_;
}
inline ::pb::Emc_Io_Plugin_Call* Container::release_io_plugin_call() {
  clear_has_io_plugin_call();
  ::pb::Emc_Io_Plugin_Call* temp = io_plugin_call_;
  io_plugin_call_ = NULL;
  return temp;
}
inline void Container::set_allocated_io_plugin_call(::pb::Emc_Io_Plugin_Call* io_plugin_call) {
  delete io_plugin_call_;
  io_plugin_call_ = io_plugin_call;
  if (io_plugin_call) {
    set_has_io_plugin_call();
  } else {
    clear_has_io_plugin_call();
  }
}

// optional bytes pru_firmware = 2048;
inline bool Container::has_pru_firmware() const {
  return (_has_bits_[2] & 0x80000000u) != 0;
}
inline void Container::set_has_pru_firmware() {
  _has_bits_[2] |= 0x80000000u;
}
inline void Container::clear_has_pru_firmware() {
  _has_bits_[2] &= ~0x80000000u;
}
inline void Container::clear_pru_firmware() {
  if (pru_firmware_ != &::google::protobuf::internal::kEmptyString) {
    pru_firmware_->clear();
  }
  clear_has_pru_firmware();
}
inline const ::std::string& Container::pru_firmware() const {
  return *pru_firmware_;
}
inline void Container::set_pru_firmware(const ::std::string& value) {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  pru_firmware_->assign(value);
}
inline void Container::set_pru_firmware(const char* value) {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  pru_firmware_->assign(value);
}
inline void Container::set_pru_firmware(const void* value, size_t size) {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  pru_firmware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_pru_firmware() {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  return pru_firmware_;
}
inline ::std::string* Container::release_pru_firmware() {
  clear_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pru_firmware_;
    pru_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_pru_firmware(::std::string* pru_firmware) {
  if (pru_firmware_ != &::google::protobuf::internal::kEmptyString) {
    delete pru_firmware_;
  }
  if (pru_firmware) {
    set_has_pru_firmware();
    pru_firmware_ = pru_firmware;
  } else {
    clear_has_pru_firmware();
    pru_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mesa_5i20_firmware = 3000;
inline bool Container::has_mesa_5i20_firmware() const {
  return (_has_bits_[3] & 0x00000001u) != 0;
}
inline void Container::set_has_mesa_5i20_firmware() {
  _has_bits_[3] |= 0x00000001u;
}
inline void Container::clear_has_mesa_5i20_firmware() {
  _has_bits_[3] &= ~0x00000001u;
}
inline void Container::clear_mesa_5i20_firmware() {
  if (mesa_5i20_firmware_ != &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_->clear();
  }
  clear_has_mesa_5i20_firmware();
}
inline const ::std::string& Container::mesa_5i20_firmware() const {
  return *mesa_5i20_firmware_;
}
inline void Container::set_mesa_5i20_firmware(const ::std::string& value) {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  mesa_5i20_firmware_->assign(value);
}
inline void Container::set_mesa_5i20_firmware(const char* value) {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  mesa_5i20_firmware_->assign(value);
}
inline void Container::set_mesa_5i20_firmware(const void* value, size_t size) {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  mesa_5i20_firmware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_mesa_5i20_firmware() {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  return mesa_5i20_firmware_;
}
inline ::std::string* Container::release_mesa_5i20_firmware() {
  clear_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mesa_5i20_firmware_;
    mesa_5i20_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_mesa_5i20_firmware(::std::string* mesa_5i20_firmware) {
  if (mesa_5i20_firmware_ != &::google::protobuf::internal::kEmptyString) {
    delete mesa_5i20_firmware_;
  }
  if (mesa_5i20_firmware) {
    set_has_mesa_5i20_firmware();
    mesa_5i20_firmware_ = mesa_5i20_firmware;
  } else {
    clear_has_mesa_5i20_firmware();
    mesa_5i20_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.Test1 test1 = 5001;
inline bool Container::has_test1() const {
  return (_has_bits_[3] & 0x00000002u) != 0;
}
inline void Container::set_has_test1() {
  _has_bits_[3] |= 0x00000002u;
}
inline void Container::clear_has_test1() {
  _has_bits_[3] &= ~0x00000002u;
}
inline void Container::clear_test1() {
  if (test1_ != NULL) test1_->::pb::Test1::Clear();
  clear_has_test1();
}
inline const ::pb::Test1& Container::test1() const {
  return test1_ != NULL ? *test1_ : *default_instance_->test1_;
}
inline ::pb::Test1* Container::mutable_test1() {
  set_has_test1();
  if (test1_ == NULL) test1_ = new ::pb::Test1;
  return test1_;
}
inline ::pb::Test1* Container::release_test1() {
  clear_has_test1();
  ::pb::Test1* temp = test1_;
  test1_ = NULL;
  return temp;
}
inline void Container::set_allocated_test1(::pb::Test1* test1) {
  delete test1_;
  test1_ = test1;
  if (test1) {
    set_has_test1();
  } else {
    clear_has_test1();
  }
}

// optional .pb.Test2 test2 = 5002;
inline bool Container::has_test2() const {
  return (_has_bits_[3] & 0x00000004u) != 0;
}
inline void Container::set_has_test2() {
  _has_bits_[3] |= 0x00000004u;
}
inline void Container::clear_has_test2() {
  _has_bits_[3] &= ~0x00000004u;
}
inline void Container::clear_test2() {
  if (test2_ != NULL) test2_->::pb::Test2::Clear();
  clear_has_test2();
}
inline const ::pb::Test2& Container::test2() const {
  return test2_ != NULL ? *test2_ : *default_instance_->test2_;
}
inline ::pb::Test2* Container::mutable_test2() {
  set_has_test2();
  if (test2_ == NULL) test2_ = new ::pb::Test2;
  return test2_;
}
inline ::pb::Test2* Container::release_test2() {
  clear_has_test2();
  ::pb::Test2* temp = test2_;
  test2_ = NULL;
  return temp;
}
inline void Container::set_allocated_test2(::pb::Test2* test2) {
  delete test2_;
  test2_ = test2;
  if (test2) {
    set_has_test2();
  } else {
    clear_has_test2();
  }
}

// optional .pb.Test3 test3 = 5003;
inline bool Container::has_test3() const {
  return (_has_bits_[3] & 0x00000008u) != 0;
}
inline void Container::set_has_test3() {
  _has_bits_[3] |= 0x00000008u;
}
inline void Container::clear_has_test3() {
  _has_bits_[3] &= ~0x00000008u;
}
inline void Container::clear_test3() {
  if (test3_ != NULL) test3_->::pb::Test3::Clear();
  clear_has_test3();
}
inline const ::pb::Test3& Container::test3() const {
  return test3_ != NULL ? *test3_ : *default_instance_->test3_;
}
inline ::pb::Test3* Container::mutable_test3() {
  set_has_test3();
  if (test3_ == NULL) test3_ = new ::pb::Test3;
  return test3_;
}
inline ::pb::Test3* Container::release_test3() {
  clear_has_test3();
  ::pb::Test3* temp = test3_;
  test3_ = NULL;
  return temp;
}
inline void Container::set_allocated_test3(::pb::Test3* test3) {
  delete test3_;
  test3_ = test3;
  if (test3) {
    set_has_test3();
  } else {
    clear_has_test3();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
